import { __assign, __rest } from "tslib";
import { getGlobalObject, logger } from '@sentry/utils';
import { msToSec } from './utils';
var global = getGlobalObject();
/** Class tracking metrics  */
var MetricsInstrumentation = /** @class */ (function () {
    function MetricsInstrumentation() {
        this._lcp = {};
        this._performanceCursor = 0;
        this._forceLCP = function () {
            /* No-op, replaced later if LCP API is available. */
            return;
        };
        if (global && global.performance) {
            if (global.performance.mark) {
                global.performance.mark('sentry-tracing-init');
            }
            this._trackLCP();
        }
    }
    /** Add performance related spans to a transaction */
    MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {
        if (!global || !global.performance || !global.performance.getEntries) {
            // Gatekeeper if performance API not available
            return;
        }
        logger.log('[Tracing] Adding & adjusting spans using Performance API');
        // TODO(fixme): depending on the 'op' directly is brittle.
        if (transaction.op === 'pageload') {
            // Force any pending records to be dispatched.
            this._forceLCP();
            if (this._lcp) {
                // Set the last observed LCP score.
                transaction.setData('_sentry_web_vitals', { LCP: this._lcp });
            }
        }
        var timeOrigin = msToSec(performance.timeOrigin);
        var entryScriptSrc;
        if (global.document) {
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (var i = 0; i < document.scripts.length; i++) {
                // We go through all scripts on the page and look for 'data-entry'
                // We remember the name and measure the time between this script finished loading and
                // our mark 'sentry-tracing-init'
                if (document.scripts[i].dataset.entry === 'true') {
                    entryScriptSrc = document.scripts[i].src;
                    break;
                }
            }
        }
        var entryScriptStartTimestamp;
        var tracingInitMarkStartTime;
        global.performance
            .getEntries()
            .slice(this._performanceCursor)
            .forEach(function (entry) {
            var startTime = msToSec(entry.startTime);
            var duration = msToSec(entry.duration);
            if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {
                return;
            }
            switch (entry.entryType) {
                case 'navigation':
                    addNavigationSpans(transaction, entry, timeOrigin);
                    break;
                case 'mark':
                case 'paint':
                case 'measure': {
                    var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
                    if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {
                        tracingInitMarkStartTime = startTimestamp;
                    }
                    break;
                }
                case 'resource': {
                    var resourceName = entry.name.replace(window.location.origin, '');
                    var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
                    // We remember the entry script end time to calculate the difference to the first init mark
                    if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {
                        entryScriptStartTimestamp = endTimestamp;
                    }
                    break;
                }
                default:
                // Ignore other entry types.
            }
        });
        if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {
            _startChild(transaction, {
                description: 'evaluation',
                endTimestamp: tracingInitMarkStartTime,
                op: 'script',
                startTimestamp: entryScriptStartTimestamp,
            });
        }
        this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
    };
    /** Starts tracking the Largest Contentful Paint on the current page. */
    MetricsInstrumentation.prototype._trackLCP = function () {
        var _this = this;
        // Based on reference implementation from https://web.dev/lcp/#measure-lcp-in-javascript.
        // Use a try/catch instead of feature detecting `largest-contentful-paint`
        // support, since some browsers throw when using the new `type` option.
        // https://bugs.webkit.org/show_bug.cgi?id=209216
        try {
            // Keep track of whether (and when) the page was first hidden, see:
            // https://github.com/w3c/page-visibility/issues/29
            // NOTE: ideally this check would be performed in the document <head>
            // to avoid cases where the visibility state changes before this code runs.
            var firstHiddenTime_1 = document.visibilityState === 'hidden' ? 0 : Infinity;
            document.addEventListener('visibilitychange', function (event) {
                firstHiddenTime_1 = Math.min(firstHiddenTime_1, event.timeStamp);
            }, { once: true });
            var updateLCP_1 = function (entry) {
                // Only include an LCP entry if the page wasn't hidden prior to
                // the entry being dispatched. This typically happens when a page is
                // loaded in a background tab.
                if (entry.startTime < firstHiddenTime_1) {
                    // NOTE: the `startTime` value is a getter that returns the entry's
                    // `renderTime` value, if available, or its `loadTime` value otherwise.
                    // The `renderTime` value may not be available if the element is an image
                    // that's loaded cross-origin without the `Timing-Allow-Origin` header.
                    _this._lcp = __assign(__assign(__assign({}, (entry.id && { elementId: entry.id })), (entry.size && { elementSize: entry.size })), { value: entry.startTime });
                }
            };
            // Create a PerformanceObserver that calls `updateLCP` for each entry.
            var po_1 = new PerformanceObserver(function (entryList) {
                entryList.getEntries().forEach(updateLCP_1);
            });
            // Observe entries of type `largest-contentful-paint`, including buffered entries,
            // i.e. entries that occurred before calling `observe()` below.
            po_1.observe({
                buffered: true,
                // @ts-ignore type does not exist on obj
                type: 'largest-contentful-paint',
            });
            this._forceLCP = function () {
                if (po_1.takeRecords) {
                    po_1.takeRecords().forEach(updateLCP_1);
                }
            };
        }
        catch (e) {
            // Do nothing if the browser doesn't support this API.
        }
    };
    return MetricsInstrumentation;
}());
export { MetricsInstrumentation };
/** Instrument navigation entries */
function addNavigationSpans(transaction, entry, timeOrigin) {
    addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);
    addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);
    addRequest(transaction, entry, timeOrigin);
}
/** Create measure related spans */
function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
    var measureStartTimestamp = timeOrigin + startTime;
    var measureEndTimestamp = measureStartTimestamp + duration;
    _startChild(transaction, {
        description: entry.name,
        endTimestamp: measureEndTimestamp,
        op: entry.entryType,
        startTimestamp: measureStartTimestamp,
    });
    return measureStartTimestamp;
}
/** Create resource related spans */
export function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
    // we already instrument based on fetch and xhr, so we don't need to
    // duplicate spans here.
    if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {
        return undefined;
    }
    var data = {};
    if ('transferSize' in entry) {
        data['Transfer Size'] = entry.transferSize;
    }
    if ('encodedBodySize' in entry) {
        data['Encoded Body Size'] = entry.encodedBodySize;
    }
    if ('decodedBodySize' in entry) {
        data['Decoded Body Size'] = entry.decodedBodySize;
    }
    var startTimestamp = timeOrigin + startTime;
    var endTimestamp = startTimestamp + duration;
    _startChild(transaction, {
        description: resourceName,
        endTimestamp: endTimestamp,
        op: entry.initiatorType ? "resource." + entry.initiatorType : 'resource',
        startTimestamp: startTimestamp,
        data: data,
    });
    return endTimestamp;
}
/** Create performance navigation related spans */
function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin) {
    var end = entry[event + "End"];
    var start = entry[event + "Start"];
    if (!start || !end) {
        return;
    }
    _startChild(transaction, {
        description: event,
        endTimestamp: timeOrigin + msToSec(end),
        op: 'browser',
        startTimestamp: timeOrigin + msToSec(start),
    });
}
/** Create request and response related spans */
function addRequest(transaction, entry, timeOrigin) {
    _startChild(transaction, {
        description: 'request',
        endTimestamp: timeOrigin + msToSec(entry.responseEnd),
        op: 'browser',
        startTimestamp: timeOrigin + msToSec(entry.requestStart),
    });
    _startChild(transaction, {
        description: 'response',
        endTimestamp: timeOrigin + msToSec(entry.responseEnd),
        op: 'browser',
        startTimestamp: timeOrigin + msToSec(entry.responseStart),
    });
}
/**
 * Helper function to start child on transactions. This function will make sure that the transaction will
 * use the start timestamp of the created child span if it is earlier than the transactions actual
 * start timestamp.
 */
export function _startChild(transaction, _a) {
    var startTimestamp = _a.startTimestamp, ctx = __rest(_a, ["startTimestamp"]);
    if (startTimestamp && transaction.startTimestamp > startTimestamp) {
        transaction.startTimestamp = startTimestamp;
    }
    return transaction.startChild(__assign({ startTimestamp: startTimestamp }, ctx));
}
//# sourceMappingURL=metrics.js.map