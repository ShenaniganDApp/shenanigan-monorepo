"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const task_names_1 = require("@nomiclabs/buidler/builtin-tasks/task-names");
const config_1 = require("@nomiclabs/buidler/config");
const glob_1 = require("@nomiclabs/buidler/internal/util/glob");
const plugins_1 = require("@nomiclabs/buidler/plugins");
const path_1 = require("path");
const artifacts_1 = require("./artifacts");
const fixture_1 = require("./fixture");
const provisioner_1 = require("./provisioner");
const task_names_2 = require("./task-names");
// See buidler-core's CONTRIBUTING.md
let originalFormatter;
let originalGetGasEstimate;
let originalPrepareCall;
function default_1() {
    config_1.usePlugin("@nomiclabs/buidler-web3");
    let accounts;
    config_1.extendEnvironment((env) => {
        env.artifacts = plugins_1.lazyObject(() => {
            const networkConfig = env.network.config;
            const provisioner = new provisioner_1.LazyTruffleContractProvisioner(env.web3, networkConfig);
            const artifacts = new artifacts_1.TruffleEnvironmentArtifacts(env.config.paths.artifacts, provisioner);
            const execute = require("@nomiclabs/truffle-contract/lib/execute");
            let noDefaultAccounts = false;
            let defaultAccount = networkConfig.from;
            async function addFromIfNeededAndAvailable(params) {
                if (noDefaultAccounts) {
                    return;
                }
                if (params.from === undefined) {
                    if (defaultAccount === undefined) {
                        accounts = await env.web3.eth.getAccounts();
                        if (accounts.length === 0) {
                            noDefaultAccounts = true;
                            return;
                        }
                        defaultAccount = accounts[0];
                    }
                    params.from = defaultAccount;
                }
            }
            const web3Path = require.resolve("web3");
            const formattersPath = require.resolve("web3-core-helpers/src/formatters", {
                paths: [web3Path],
            });
            const formatters = require(formattersPath);
            if (originalFormatter === undefined) {
                originalFormatter = formatters.inputTransactionFormatter;
            }
            formatters.inputTransactionFormatter = function (options) {
                if (options.from === undefined) {
                    throw new plugins_1.BuidlerPluginError("There's no account available in the selected network.");
                }
                return originalFormatter(options);
            };
            if (originalGetGasEstimate === undefined) {
                originalGetGasEstimate = execute.getGasEstimate;
            }
            execute.getGasEstimate = async function (params, ...others) {
                await addFromIfNeededAndAvailable(params);
                return originalGetGasEstimate.call(this, params, ...others);
            };
            if (originalPrepareCall === undefined) {
                originalPrepareCall = execute.prepareCall;
            }
            execute.prepareCall = async function (...args) {
                const ret = await originalPrepareCall.apply(this, args);
                await addFromIfNeededAndAvailable(ret.params);
                return ret;
            };
            return artifacts;
        });
        env.assert = plugins_1.lazyFunction(() => require("chai").assert);
        env.expect = plugins_1.lazyFunction(() => require("chai").expect);
        env.contract = (description, definition) => {
            if (env.network.name === plugins_1.BUIDLEREVM_NETWORK_NAME) {
                if (accounts === undefined) {
                    const { privateToAddress, toChecksumAddress, bufferToHex, } = require("ethereumjs-util");
                    const netConfig = env.network.config;
                    accounts = netConfig.accounts.map((acc) => toChecksumAddress(bufferToHex(privateToAddress(acc.privateKey))));
                }
            }
            else if (accounts === undefined) {
                throw new plugins_1.BuidlerPluginError(`To run your tests that use Truffle's "contract()" function with the network "${env.network.name}", you need to use Buidler's CLI`);
            }
            describe(`Contract: ${description}`, () => {
                before("Running truffle fixture if available", async function () {
                    await env.run(task_names_2.RUN_TRUFFLE_FIXTURE_TASK);
                });
                definition(accounts);
            });
        };
    });
    config_1.internalTask(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT, async (_, { web3, network }) => {
        if (network.name !== plugins_1.BUIDLEREVM_NETWORK_NAME) {
            accounts = await web3.eth.getAccounts();
        }
    });
    config_1.internalTask(task_names_1.TASK_COMPILE_GET_SOURCE_PATHS, async (_, { config }, runSuper) => {
        const sources = await runSuper();
        const testSources = await glob_1.glob(path_1.join(config.paths.tests, "**", "*.sol"));
        return [...sources, ...testSources];
    });
    let wasWarningShown = false;
    config_1.internalTask(task_names_2.RUN_TRUFFLE_FIXTURE_TASK, async (_, env) => {
        const paths = env.config.paths;
        const hasFixture = await fixture_1.hasTruffleFixture(paths);
        if (!wasWarningShown) {
            if ((await fixture_1.hasMigrations(paths)) && !hasFixture) {
                console.warn("Your project has Truffle migrations, which have to be turn into a fixture to run your tests with Buidler");
                wasWarningShown = true;
            }
        }
        if (hasFixture) {
            const fixture = await fixture_1.getTruffleFixtureFunction(paths);
            await fixture(env);
        }
    });
}
exports.default = default_1;
//# sourceMappingURL=index.js.map