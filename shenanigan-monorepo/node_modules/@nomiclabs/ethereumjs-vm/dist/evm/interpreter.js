"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BN = require("bn.js");
const exceptions_1 = require("../exceptions");
const memory_1 = require("./memory");
const stack_1 = require("./stack");
const opFns_1 = require("./opFns");
/**
 * Parses and executes EVM bytecode.
 */
class Interpreter {
    constructor(vm, eei) {
        this._vm = vm; // TODO: remove when not needed
        this._state = vm.pStateManager;
        this._eei = eei;
        this._runState = {
            programCounter: 0,
            opCode: 0xfe,
            memory: new memory_1.default(),
            memoryWordCount: new BN(0),
            highestMemCost: new BN(0),
            stack: new stack_1.default(),
            code: Buffer.alloc(0),
            validJumps: [],
            // TODO: Replace with EEI methods
            _common: this._vm._common,
            stateManager: this._state._wrapped,
            eei: this._eei,
        };
    }
    async run(code, opts = {}) {
        this._runState.code = code;
        this._runState.programCounter = opts.pc || this._runState.programCounter;
        this._runState.validJumps = this._getValidJumpDests(code);
        // Check that the programCounter is in range
        const pc = this._runState.programCounter;
        if (pc !== 0 && (pc < 0 || pc >= this._runState.code.length)) {
            throw new Error('Internal error: program counter not in range');
        }
        let err;
        // Iterate through the given ops until something breaks or we hit STOP
        while (this._runState.programCounter < this._runState.code.length) {
            const opCode = this._runState.code[this._runState.programCounter];
            this._runState.opCode = opCode;
            await this._runStepHook();
            try {
                await this.runStep();
            }
            catch (e) {
                // STOP is not an exception
                if (e.error !== exceptions_1.ERROR.STOP) {
                    err = e;
                }
                // TODO: Throw on non-VmError exceptions
                break;
            }
        }
        return {
            runState: this._runState,
            exceptionError: err,
        };
    }
    /**
     * Executes the opcode to which the program counter is pointing,
     * reducing it's base gas cost, and increments the program counter.
     */
    async runStep() {
        const opInfo = this.lookupOpInfo(this._runState.opCode);
        // Check for invalid opcode
        if (opInfo.name === 'INVALID') {
            throw new exceptions_1.VmError(exceptions_1.ERROR.INVALID_OPCODE);
        }
        // Reduce opcode's base fee
        this._eei.useGas(new BN(opInfo.fee));
        // Advance program counter
        this._runState.programCounter++;
        // Execute opcode handler
        const opFn = this.getOpHandler(opInfo);
        if (opInfo.isAsync) {
            await opFn.apply(null, [this._runState]);
        }
        else {
            opFn.apply(null, [this._runState]);
        }
    }
    /**
     * Get the handler function for an opcode.
     */
    getOpHandler(opInfo) {
        return opFns_1.handlers[opInfo.name];
    }
    /**
     * Get info for an opcode from VM's list of opcodes.
     */
    lookupOpInfo(op, full = false) {
        const opcode = this._vm._opcodes[op]
            ? this._vm._opcodes[op]
            : { name: 'INVALID', fee: 0, isAsync: false };
        if (full) {
            let name = opcode.name;
            if (name === 'LOG') {
                name += op - 0xa0;
            }
            if (name === 'PUSH') {
                name += op - 0x5f;
            }
            if (name === 'DUP') {
                name += op - 0x7f;
            }
            if (name === 'SWAP') {
                name += op - 0x8f;
            }
            return Object.assign(Object.assign({}, opcode), { name });
        }
        return opcode;
    }
    async _runStepHook() {
        const eventObj = {
            pc: this._runState.programCounter,
            gasLeft: this._eei.getGasLeft(),
            opcode: this.lookupOpInfo(this._runState.opCode, true),
            stack: this._runState.stack._store,
            depth: this._eei._env.depth,
            address: this._eei._env.address,
            account: this._eei._env.contract,
            stateManager: this._runState.stateManager,
            memory: this._runState.memory._store,
            memoryWordCount: this._runState.memoryWordCount,
            codeAddress: this._eei._env.codeAddress,
        };
        /**
         * The `step` event for trace output
         *
         * @event Event: step
         * @type {Object}
         * @property {Number} pc representing the program counter
         * @property {String} opcode the next opcode to be ran
         * @property {BN} gasLeft amount of gasLeft
         * @property {Array} stack an `Array` of `Buffers` containing the stack
         * @property {Account} account the [`Account`](https://github.com/ethereum/ethereumjs-account) which owns the code running
         * @property {Buffer} address the address of the `account`
         * @property {Number} depth the current number of calls deep the contract is
         * @property {Buffer} memory the memory of the VM as a `buffer`
         * @property {BN} memoryWordCount current size of memory in words
         * @property {StateManager} stateManager a [`StateManager`](stateManager.md) instance (Beta API)
         */
        return this._vm._emit('step', eventObj);
    }
    // Returns all valid jump destinations.
    _getValidJumpDests(code) {
        const jumps = [];
        for (let i = 0; i < code.length; i++) {
            const curOpCode = this.lookupOpInfo(code[i]).name;
            // no destinations into the middle of PUSH
            if (curOpCode === 'PUSH') {
                i += code[i] - 0x5f;
            }
            if (curOpCode === 'JUMPDEST') {
                jumps.push(i);
            }
        }
        return jumps;
    }
}
exports.default = Interpreter;
//# sourceMappingURL=interpreter.js.map