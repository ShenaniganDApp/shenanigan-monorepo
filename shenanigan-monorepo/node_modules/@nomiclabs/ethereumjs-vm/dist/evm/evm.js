"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OOGResult = void 0;
const BN = require("bn.js");
const ethereumjs_util_1 = require("ethereumjs-util");
const exceptions_1 = require("../exceptions");
const precompiles_1 = require("./precompiles");
const eei_1 = require("./eei");
const interpreter_1 = require("./interpreter");
const Block = require('ethereumjs-block');
function OOGResult(gasLimit) {
    return {
        returnValue: Buffer.alloc(0),
        gasUsed: gasLimit,
        exceptionError: new exceptions_1.VmError(exceptions_1.ERROR.OUT_OF_GAS),
    };
}
exports.OOGResult = OOGResult;
/**
 * EVM is responsible for executing an EVM message fully
 * (including any nested calls and creates), processing the results
 * and storing them to state (or discarding changes in case of exceptions).
 * @ignore
 */
class EVM {
    constructor(vm, txContext, block) {
        this._vm = vm;
        this._state = this._vm.pStateManager;
        this._tx = txContext;
        this._block = block;
        this._refund = new BN(0);
    }
    /**
     * Executes an EVM message, determining whether it's a call or create
     * based on the `to` address. It checkpoints the state and reverts changes
     * if an exception happens during the message execution.
     */
    async executeMessage(message) {
        await this._vm._emit('beforeMessage', message);
        await this._state.checkpoint();
        let result;
        if (message.to) {
            result = await this._executeCall(message);
        }
        else {
            result = await this._executeCreate(message);
        }
        // TODO: Move `gasRefund` to a tx-level result object
        // instead of `ExecResult`.
        result.execResult.gasRefund = this._refund.clone();
        const err = result.execResult.exceptionError;
        if (err) {
            result.execResult.logs = [];
            await this._state.revert();
        }
        else {
            await this._state.commit();
        }
        await this._vm._emit('afterMessage', result);
        return result;
    }
    async _executeCall(message) {
        const account = await this._state.getAccount(message.caller);
        // Reduce tx value from sender
        if (!message.delegatecall) {
            await this._reduceSenderBalance(account, message);
        }
        // Load `to` account
        const toAccount = await this._state.getAccount(message.to);
        // Add tx value to the `to` account
        if (!message.delegatecall) {
            await this._addToBalance(toAccount, message);
        }
        // Load code
        await this._loadCode(message);
        if (!message.code || message.code.length === 0) {
            return {
                gasUsed: new BN(0),
                execResult: {
                    gasUsed: new BN(0),
                    returnValue: Buffer.alloc(0),
                },
            };
        }
        let result;
        if (message.isCompiled) {
            result = this.runPrecompile(message.code, message.data, message.gasLimit);
        }
        else {
            result = await this.runInterpreter(message);
        }
        return {
            gasUsed: result.gasUsed,
            execResult: result,
        };
    }
    async _executeCreate(message) {
        const account = await this._state.getAccount(message.caller);
        // Reduce tx value from sender
        await this._reduceSenderBalance(account, message);
        message.code = message.data;
        message.data = Buffer.alloc(0);
        message.to = await this._generateAddress(message);
        let toAccount = await this._state.getAccount(message.to);
        // Check for collision
        if ((toAccount.nonce && new BN(toAccount.nonce).gtn(0)) ||
            toAccount.codeHash.compare(ethereumjs_util_1.KECCAK256_NULL) !== 0) {
            return {
                gasUsed: message.gasLimit,
                createdAddress: message.to,
                execResult: {
                    returnValue: Buffer.alloc(0),
                    exceptionError: new exceptions_1.VmError(exceptions_1.ERROR.CREATE_COLLISION),
                    gasUsed: message.gasLimit,
                },
            };
        }
        await this._state.clearContractStorage(message.to);
        const newContractEvent = {
            address: message.to,
            code: message.code,
        };
        await this._vm._emit('newContract', newContractEvent);
        toAccount = await this._state.getAccount(message.to);
        toAccount.nonce = new BN(toAccount.nonce).addn(1).toArrayLike(Buffer);
        // Add tx value to the `to` account
        await this._addToBalance(toAccount, message);
        if (!message.code || message.code.length === 0) {
            return {
                gasUsed: new BN(0),
                createdAddress: message.to,
                execResult: {
                    gasUsed: new BN(0),
                    returnValue: Buffer.alloc(0),
                },
            };
        }
        let result = await this.runInterpreter(message);
        // fee for size of the return value
        let totalGas = result.gasUsed;
        if (!result.exceptionError) {
            const returnFee = new BN(result.returnValue.length * this._vm._common.param('gasPrices', 'createData'));
            totalGas = totalGas.add(returnFee);
        }
        // if not enough gas
        if (totalGas.lte(message.gasLimit) &&
            (this._vm.allowUnlimitedContractSize || result.returnValue.length <= 24576)) {
            result.gasUsed = totalGas;
        }
        else {
            result = Object.assign(Object.assign({}, result), OOGResult(message.gasLimit));
        }
        // Save code if a new contract was created
        if (!result.exceptionError && result.returnValue && result.returnValue.toString() !== '') {
            await this._state.putContractCode(message.to, result.returnValue);
        }
        return {
            gasUsed: result.gasUsed,
            createdAddress: message.to,
            execResult: result,
        };
    }
    /**
     * Starts the actual bytecode processing for a CALL or CREATE, providing
     * it with the [[EEI]].
     */
    async runInterpreter(message, opts = {}) {
        const env = {
            blockchain: this._vm.blockchain,
            address: message.to || ethereumjs_util_1.zeros(32),
            caller: message.caller || ethereumjs_util_1.zeros(32),
            callData: message.data || Buffer.from([0]),
            callValue: message.value || new BN(0),
            code: message.code,
            isStatic: message.isStatic || false,
            depth: message.depth || 0,
            gasPrice: this._tx.gasPrice,
            origin: this._tx.origin || message.caller || ethereumjs_util_1.zeros(32),
            block: this._block || new Block(),
            contract: await this._state.getAccount(message.to || ethereumjs_util_1.zeros(32)),
            codeAddress: message.codeAddress,
        };
        const eei = new eei_1.default(env, this._state, this, this._vm._common, message.gasLimit.clone());
        if (message.selfdestruct) {
            eei._result.selfdestruct = message.selfdestruct;
        }
        const oldRefund = this._refund.clone();
        const interpreter = new interpreter_1.default(this._vm, eei);
        const interpreterRes = await interpreter.run(message.code, opts);
        let result = eei._result;
        let gasUsed = message.gasLimit.sub(eei._gasLeft);
        if (interpreterRes.exceptionError) {
            if (interpreterRes.exceptionError.error !== exceptions_1.ERROR.REVERT) {
                gasUsed = message.gasLimit;
            }
            // Clear the result on error
            result = Object.assign(Object.assign({}, result), { logs: [], selfdestruct: {} });
            // Revert gas refund if message failed
            this._refund = oldRefund;
        }
        return Object.assign(Object.assign({}, result), { runState: Object.assign(Object.assign(Object.assign({}, interpreterRes.runState), result), eei._env), exceptionError: interpreterRes.exceptionError, gas: eei._gasLeft, gasUsed, returnValue: result.returnValue ? result.returnValue : Buffer.alloc(0) });
    }
    /**
     * Returns code for precompile at the given address, or undefined
     * if no such precompile exists.
     */
    getPrecompile(address) {
        return precompiles_1.getPrecompile(address.toString('hex'));
    }
    /**
     * Executes a precompiled contract with given data and gas limit.
     */
    runPrecompile(code, data, gasLimit) {
        if (typeof code !== 'function') {
            throw new Error('Invalid precompile');
        }
        const opts = {
            data,
            gasLimit,
            _common: this._vm._common,
        };
        return code(opts);
    }
    async _loadCode(message) {
        if (!message.code) {
            const precompile = this.getPrecompile(message.codeAddress);
            if (precompile) {
                message.code = precompile;
                message.isCompiled = true;
            }
            else {
                message.code = await this._state.getContractCode(message.codeAddress);
                message.isCompiled = false;
            }
        }
    }
    async _generateAddress(message) {
        let addr;
        if (message.salt) {
            addr = ethereumjs_util_1.generateAddress2(message.caller, message.salt, message.code);
        }
        else {
            const acc = await this._state.getAccount(message.caller);
            const newNonce = new BN(acc.nonce).subn(1);
            addr = ethereumjs_util_1.generateAddress(message.caller, newNonce.toArrayLike(Buffer));
        }
        return addr;
    }
    async _reduceSenderBalance(account, message) {
        const newBalance = new BN(account.balance).sub(message.value);
        account.balance = ethereumjs_util_1.toBuffer(newBalance);
        return this._state.putAccount(ethereumjs_util_1.toBuffer(message.caller), account);
    }
    async _addToBalance(toAccount, message) {
        const newBalance = new BN(toAccount.balance).add(message.value);
        if (newBalance.gt(ethereumjs_util_1.MAX_INTEGER)) {
            throw new Error('Value overflow');
        }
        toAccount.balance = ethereumjs_util_1.toBuffer(newBalance);
        // putAccount as the nonce may have changed for contract creation
        return this._state.putAccount(ethereumjs_util_1.toBuffer(message.to), toAccount);
    }
    async _touchAccount(address) {
        const acc = await this._state.getAccount(address);
        return this._state.putAccount(address, acc);
    }
}
exports.default = EVM;
//# sourceMappingURL=evm.js.map