"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const ethereumjs_util_1 = require("ethereumjs-util");
const server_1 = require("../internal/buidler-evm/jsonrpc/server");
const constants_1 = require("../internal/constants");
const config_env_1 = require("../internal/core/config/config-env");
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
const construction_1 = require("../internal/core/providers/construction");
const reporter_1 = require("../internal/sentry/reporter");
const lazy_1 = require("../internal/util/lazy");
const task_names_1 = require("./task-names");
const watch_1 = require("./utils/watch");
const log = debug_1.default("buidler:core:tasks:node");
function _createBuidlerEVMProvider(config) {
    log("Creating BuidlerEVM Provider");
    const networkName = constants_1.BUIDLEREVM_NETWORK_NAME;
    const networkConfig = config.networks[networkName];
    return lazy_1.lazyObject(() => {
        log(`Creating buidlerevm provider for JSON-RPC sever`);
        return construction_1.createProvider(networkName, Object.assign({ loggingEnabled: true }, networkConfig), config.solc.version, config.paths);
    });
}
function logBuidlerEvmAccounts(networkConfig) {
    if (networkConfig.accounts === undefined) {
        return;
    }
    console.log("Accounts");
    console.log("========");
    for (const [index, account] of networkConfig.accounts.entries()) {
        const address = ethereumjs_util_1.bufferToHex(ethereumjs_util_1.privateToAddress(ethereumjs_util_1.toBuffer(account.privateKey)));
        const privateKey = ethereumjs_util_1.bufferToHex(ethereumjs_util_1.toBuffer(account.privateKey));
        const balance = new ethereumjs_util_1.BN(account.balance)
            .div(new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(18)))
            .toString(10);
        console.log(`Account #${index}: ${address} (${balance} ETH)
Private Key: ${privateKey}
`);
    }
}
function default_1() {
    config_env_1.task(task_names_1.TASK_NODE, "Starts a JSON-RPC server on top of Buidler EVM")
        .addOptionalParam("hostname", "The host to which to bind to for new connections", "localhost", config_env_1.types.string)
        .addOptionalParam("port", "The port on which to listen for new connections", 8545, config_env_1.types.int)
        .setAction(async ({ hostname, port }, { network, buidlerArguments, config }) => {
        if (network.name !== constants_1.BUIDLEREVM_NETWORK_NAME &&
            // We normally set the default network as buidlerArguments.network,
            // so this check isn't enough, and we add the next one. This has the
            // effect of `--network <defaultNetwork>` being a false negative, but
            // not a big deal.
            buidlerArguments.network !== undefined &&
            buidlerArguments.network !== config.defaultNetwork) {
            throw new errors_1.BuidlerError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_UNSUPPORTED_NETWORK);
        }
        try {
            const serverConfig = {
                hostname,
                port,
                provider: _createBuidlerEVMProvider(config),
            };
            const server = new server_1.JsonRpcServer(serverConfig);
            const { port: actualPort, address } = await server.listen();
            console.log(chalk_1.default.green(`Started HTTP and WebSocket JSON-RPC server at http://${address}:${actualPort}/`));
            console.log();
            try {
                await watch_1.watchCompilerOutput(server.getProvider(), config.solc, config.paths);
            }
            catch (error) {
                console.warn(chalk_1.default.yellow("There was a problem watching the compiler output, changes in the contracts won't be reflected in the Buidler EVM. Run Buidler with --verbose to learn more."));
                log("Compilation output can't be watched. Please report this to help us improve Buidler.\n", error);
                reporter_1.Reporter.reportError(error);
            }
            const networkConfig = config.networks[constants_1.BUIDLEREVM_NETWORK_NAME];
            logBuidlerEvmAccounts(networkConfig);
            await server.waitUntilClosed();
        }
        catch (error) {
            if (errors_1.BuidlerError.isBuidlerError(error)) {
                throw error;
            }
            throw new errors_1.BuidlerError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_SERVER_ERROR, {
                error: error.message,
            }, error);
        }
    });
}
exports.default = default_1;
//# sourceMappingURL=node.js.map