"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const t = __importStar(require("io-ts"));
const errors_1 = require("../errors");
const input_1 = require("../input");
// tslint:disable only-buidler-error
class BuidlerModule {
    constructor(_node) {
        this._node = _node;
    }
    async processRequest(method, params = []) {
        switch (method) {
            case "buidler_getStackTraceFailuresCount":
                return this._getStackTraceFailuresCountAction(...this._getStackTraceFailuresCountParams(params));
            case "buidler_addCompilationResult":
                return this._addCompilationResultAction(...this._addCompilationResultParams(params));
        }
        throw new errors_1.MethodNotFoundError(`Method ${method} not found`);
    }
    // buidler_getStackTraceFailuresCount
    _getStackTraceFailuresCountParams(params) {
        return input_1.validateParams(params);
    }
    async _getStackTraceFailuresCountAction() {
        return this._node.getStackTraceFailuresCount();
    }
    // buidler_addCompilationResult
    _addCompilationResultParams(params) {
        return input_1.validateParams(params, t.string, input_1.rpcCompilerInput, input_1.rpcCompilerOutput);
    }
    async _addCompilationResultAction(compilerVersion, compilerInput, compilerOutput) {
        return this._node.addCompilationResult(compilerVersion, compilerInput, compilerOutput);
    }
}
exports.BuidlerModule = BuidlerModule;
//# sourceMappingURL=buidler.js.map