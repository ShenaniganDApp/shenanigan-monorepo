"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("ethereumjs-util");
// tslint:disable only-buidler-error
function numberToRpcQuantity(n) {
    // This is here because we have some any's from dependencies
    if (typeof n !== "number" && Buffer.isBuffer(n)) {
        throw new Error(`Expected a number and got ${n}`);
    }
    if (Buffer.isBuffer(n)) {
        n = new ethereumjs_util_1.BN(n);
    }
    return `0x${n.toString(16)}`;
}
exports.numberToRpcQuantity = numberToRpcQuantity;
function bufferToRpcData(buffer, pad = 0) {
    let s = ethereumjs_util_1.bufferToHex(buffer);
    if (pad > 0 && s.length < pad + 2) {
        s = `0x${"0".repeat(pad + 2 - s.length)}${s.slice(2)}`;
    }
    return s;
}
exports.bufferToRpcData = bufferToRpcData;
function getRpcBlock(block, totalDifficulty, includeTransactions = true) {
    return {
        number: numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.number)),
        hash: bufferToRpcData(block.hash()),
        parentHash: bufferToRpcData(block.header.parentHash),
        // We pad this to 8 bytes because of a limitation in The Graph
        // See: https://github.com/nomiclabs/buidler/issues/491
        nonce: bufferToRpcData(block.header.nonce, 16),
        sha3Uncles: bufferToRpcData(block.header.uncleHash),
        logsBloom: bufferToRpcData(block.header.bloom),
        transactionsRoot: bufferToRpcData(block.header.transactionsTrie),
        stateRoot: bufferToRpcData(block.header.stateRoot),
        receiptsRoot: bufferToRpcData(block.header.receiptTrie),
        miner: bufferToRpcData(block.header.coinbase),
        difficulty: numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.difficulty)),
        totalDifficulty: numberToRpcQuantity(totalDifficulty),
        extraData: bufferToRpcData(block.header.extraData),
        size: numberToRpcQuantity(block.serialize().length),
        gasLimit: numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.gasLimit)),
        gasUsed: numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.gasUsed)),
        timestamp: numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.timestamp)),
        transactions: block.transactions.map((tx, index) => getRpcTransaction(tx, block, index, !includeTransactions)),
        uncles: block.uncleHeaders.map((uh) => bufferToRpcData(uh.hash())),
    };
}
exports.getRpcBlock = getRpcBlock;
function getRpcTransaction(tx, block, index, txHashOnly = false) {
    if (txHashOnly) {
        return bufferToRpcData(tx.hash(true));
    }
    return {
        blockHash: block !== undefined ? bufferToRpcData(block.hash()) : null,
        blockNumber: block !== undefined
            ? numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.number))
            : null,
        from: bufferToRpcData(tx.getSenderAddress()),
        gas: numberToRpcQuantity(new ethereumjs_util_1.BN(tx.gasLimit)),
        gasPrice: numberToRpcQuantity(new ethereumjs_util_1.BN(tx.gasPrice)),
        hash: bufferToRpcData(tx.hash(true)),
        input: bufferToRpcData(tx.data),
        nonce: numberToRpcQuantity(new ethereumjs_util_1.BN(tx.nonce)),
        to: tx.to.length === 0 ? null : bufferToRpcData(tx.to),
        transactionIndex: index !== undefined ? numberToRpcQuantity(index) : null,
        value: numberToRpcQuantity(new ethereumjs_util_1.BN(tx.value)),
        v: numberToRpcQuantity(new ethereumjs_util_1.BN(tx.v)),
        r: numberToRpcQuantity(new ethereumjs_util_1.BN(tx.s)),
        s: numberToRpcQuantity(new ethereumjs_util_1.BN(tx.r)),
    };
}
exports.getRpcTransaction = getRpcTransaction;
function getRpcTransactionReceipt(tx, block, index, txBlockResults) {
    const cumulativeGasUsed = txBlockResults
        .map((txbr) => txbr.receipt)
        .filter((r, i) => i <= index)
        .reduce((gas, r) => gas.add(new ethereumjs_util_1.BN(r.gasUsed)), new ethereumjs_util_1.BN(0));
    const receipt = txBlockResults[index].receipt;
    const createdAddress = txBlockResults[index].createAddresses;
    return {
        transactionHash: bufferToRpcData(tx.hash()),
        transactionIndex: numberToRpcQuantity(index),
        blockHash: bufferToRpcData(block.hash()),
        blockNumber: numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.number)),
        from: bufferToRpcData(tx.getSenderAddress()),
        to: tx.to.length === 0 ? null : bufferToRpcData(tx.to),
        cumulativeGasUsed: numberToRpcQuantity(cumulativeGasUsed),
        gasUsed: numberToRpcQuantity(new ethereumjs_util_1.BN(receipt.gasUsed)),
        contractAddress: createdAddress !== undefined ? bufferToRpcData(createdAddress) : null,
        logs: receipt.logs,
        logsBloom: bufferToRpcData(txBlockResults[index].bloomBitvector),
        status: numberToRpcQuantity(receipt.status),
    };
}
exports.getRpcTransactionReceipt = getRpcTransactionReceipt;
function getRpcLog(log, tx, block, transactionIndex, logIndex) {
    return {
        removed: false,
        logIndex: logIndex !== undefined ? numberToRpcQuantity(logIndex) : null,
        transactionIndex: transactionIndex !== undefined
            ? numberToRpcQuantity(transactionIndex)
            : null,
        transactionHash: block !== undefined ? bufferToRpcData(tx.hash()) : null,
        blockHash: block !== undefined ? bufferToRpcData(block.hash()) : null,
        blockNumber: block !== undefined
            ? numberToRpcQuantity(new ethereumjs_util_1.BN(block.header.number))
            : null,
        address: bufferToRpcData(log[0]),
        data: bufferToRpcData(log[2]),
        topics: log[1].map((topic) => bufferToRpcData(topic)),
    };
}
exports.getRpcLog = getRpcLog;
//# sourceMappingURL=output.js.map