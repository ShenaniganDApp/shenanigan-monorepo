"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const errors_1 = require("../../core/errors");
const errors_list_1 = require("../../core/errors-list");
const COMPILER_FILES_DIR_URL = "https://raw.githubusercontent.com/ethereum/solc-bin/gh-pages/bin/";
const COMPILERS_LIST_URL = `${COMPILER_FILES_DIR_URL}list.json`;
async function downloadFile(url, destinationFile) {
    // This library indirectly validates the TLS certs, if it didn't this
    // would be MITM-able.
    const { default: download } = await Promise.resolve().then(() => __importStar(require("download")));
    await download(url, path_1.default.dirname(destinationFile), {
        filename: path_1.default.basename(destinationFile),
    });
}
class CompilerDownloader {
    constructor(compilersDir, localSolcVersion, download = downloadFile) {
        this.compilersDir = compilersDir;
        this.localSolcVersion = localSolcVersion;
        this.download = download;
        this._compilersDir = compilersDir;
        this._localSolcVersion = localSolcVersion;
        this._download = download;
    }
    async getDownloadedCompilerPath(version) {
        const compilerBuild = await this.getCompilerBuild(version);
        const downloadedFilePath = path_1.default.join(this._compilersDir, compilerBuild.path);
        if (!(await this._fileExists(downloadedFilePath))) {
            await this.downloadCompiler(compilerBuild, downloadedFilePath);
        }
        await this.verifyCompiler(compilerBuild, downloadedFilePath);
        return downloadedFilePath;
    }
    async getCompilerBuild(version) {
        const compilersListExisted = await this.compilersListExists();
        let list = await this.getCompilersList();
        let compilerBuildPath = list.releases[version];
        // We may need to re-download the compilers list.
        if (compilerBuildPath === undefined && compilersListExisted) {
            await fs_extra_1.default.unlink(this.getCompilersListPath());
            list = await this.getCompilersList();
            compilerBuildPath = list.releases[version];
        }
        const compilerBuild = list.builds.find((b) => b.path === compilerBuildPath);
        if (compilerBuild === undefined) {
            throw new errors_1.BuidlerError(errors_list_1.ERRORS.SOLC.INVALID_VERSION, { version });
        }
        return compilerBuild;
    }
    async getCompilersList() {
        if (!(await this.compilersListExists())) {
            await this.downloadCompilersList();
        }
        return fs_extra_1.default.readJson(this.getCompilersListPath());
    }
    getCompilersListPath() {
        return path_1.default.join(this._compilersDir, "list.json");
    }
    async compilersListExists() {
        return fs_extra_1.default.pathExists(this.getCompilersListPath());
    }
    async downloadCompilersList() {
        try {
            await this._download(COMPILERS_LIST_URL, this.getCompilersListPath());
        }
        catch (error) {
            throw new errors_1.BuidlerError(errors_list_1.ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED, {
                localVersion: this._localSolcVersion,
            }, error);
        }
    }
    async downloadCompiler(compilerBuild, downloadedFilePath) {
        console.debug(`Downloading compiler version ${compilerBuild.version}`);
        const compilerUrl = COMPILER_FILES_DIR_URL + compilerBuild.path;
        try {
            await this._download(compilerUrl, downloadedFilePath);
        }
        catch (error) {
            throw new errors_1.BuidlerError(errors_list_1.ERRORS.SOLC.DOWNLOAD_FAILED, {
                remoteVersion: compilerBuild.version,
                localVersion: this._localSolcVersion,
            }, error);
        }
    }
    async verifyCompiler(compilerBuild, downloadedFilePath) {
        const ethereumjsUtil = await Promise.resolve().then(() => __importStar(require("ethereumjs-util")));
        const expectedKeccak256 = compilerBuild.keccak256;
        const compiler = await fs_extra_1.default.readFile(downloadedFilePath);
        const compilerKeccak256 = ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak(compiler));
        if (expectedKeccak256 !== compilerKeccak256) {
            await fs_extra_1.default.unlink(downloadedFilePath);
            throw new errors_1.BuidlerError(errors_list_1.ERRORS.SOLC.INVALID_DOWNLOAD, {
                remoteVersion: compilerBuild.version,
                localVersion: this._localSolcVersion,
            });
        }
    }
    async _fileExists(filePath) {
        return fs_extra_1.default.pathExists(filePath);
    }
}
exports.CompilerDownloader = CompilerDownloader;
//# sourceMappingURL=downloader.js.map