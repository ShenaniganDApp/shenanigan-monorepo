"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const errors_list_1 = require("../errors-list");
function rpcQuantityToNumber(quantity) {
    if (quantity === undefined) {
        throw new errors_1.BuidlerError(errors_list_1.ERRORS.NETWORK.INVALID_RPC_QUANTITY_VALUE, {
            value: quantity,
        });
    }
    if (typeof quantity !== "string" ||
        quantity.match(/^0x(?:0|(?:[1-9a-fA-F][0-9a-fA-F]*))$/) === null) {
        throw new errors_1.BuidlerError(errors_list_1.ERRORS.NETWORK.INVALID_RPC_QUANTITY_VALUE, {
            value: quantity,
        });
    }
    return parseInt(quantity.substring(2), 16);
}
exports.rpcQuantityToNumber = rpcQuantityToNumber;
function numberToRpcQuantity(n) {
    const hex = n.toString(16);
    return `0x${hex}`;
}
exports.numberToRpcQuantity = numberToRpcQuantity;
function createChainIdGetter(provider) {
    let cachedChainId;
    return async function getRealChainId() {
        if (cachedChainId === undefined) {
            try {
                const id = await provider.send("eth_chainId");
                cachedChainId = rpcQuantityToNumber(id);
            }
            catch (error) {
                // If eth_chainId fails we default to net_version
                // TODO: This should be removed in the future.
                // See: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-695.md
                const id = await provider.send("net_version");
                cachedChainId = id.startsWith("0x")
                    ? rpcQuantityToNumber(id)
                    : parseInt(id, 10);
            }
        }
        return cachedChainId;
    };
}
exports.createChainIdGetter = createChainIdGetter;
//# sourceMappingURL=provider-utils.js.map