"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/require-await */
// This rule seems to be flickering and buggy - does not understand async arrow functions correctly
const test_helpers_1 = require("@openzeppelin/test-helpers");
const bn_js_1 = __importDefault(require("bn.js"));
const ethereumjs_tx_1 = require("ethereumjs-tx");
const ethereumjs_util_1 = require("ethereumjs-util");
const rlp_1 = require("rlp");
const chai_1 = require("chai");
const Utils_1 = require("../src/common/Utils");
const TypedRequestData_1 = __importStar(require("../src/common/EIP712/TypedRequestData"));
const Environments_1 = require("../src/common/Environments");
const TestUtils_1 = require("./TestUtils");
const RelayHub = artifacts.require('RelayHub');
const StakeManager = artifacts.require('StakeManager');
const Penalizer = artifacts.require('Penalizer');
const TestRecipient = artifacts.require('TestRecipient');
const TestPaymasterEverythingAccepted = artifacts.require('TestPaymasterEverythingAccepted');
const Forwarder = artifacts.require('Forwarder');
const paymasterData = '0x';
const clientId = '0';
contract('RelayHub Penalizations', function ([_, relayOwner, relayWorker, otherRelayWorker, sender, other, relayManager, otherRelayManager, thirdRelayWorker]) {
    const chainId = Environments_1.defaultEnvironment.chainId;
    let stakeManager;
    let relayHub;
    let penalizer;
    let recipient;
    let paymaster;
    let forwarder;
    // TODO: 'before' is a bad thing in general. Use 'beforeEach', this tests all depend on each other!!!
    before(async function () {
        stakeManager = await StakeManager.new();
        penalizer = await Penalizer.new();
        relayHub = await TestUtils_1.deployHub(stakeManager.address, penalizer.address);
        const forwarderInstance = await Forwarder.new();
        forwarder = forwarderInstance.address;
        recipient = await TestRecipient.new(forwarder);
        // register hub's RelayRequest with forwarder, if not already done.
        await forwarderInstance.registerRequestType(TypedRequestData_1.GsnRequestType.typeName, TypedRequestData_1.GsnRequestType.typeSuffix);
        paymaster = await TestPaymasterEverythingAccepted.new();
        await stakeManager.stakeForAddress(relayManager, 1000, {
            from: relayOwner,
            value: test_helpers_1.ether('1')
        });
        await stakeManager.authorizeHubByOwner(relayManager, relayHub.address, { from: relayOwner });
        await paymaster.setRelayHub(relayHub.address);
        await relayHub.addRelayWorkers([relayWorker], { from: relayManager });
        // @ts-ignore
        Object.keys(StakeManager.events).forEach(function (topic) {
            // @ts-ignore
            RelayHub.network.events[topic] = StakeManager.events[topic];
        });
        // @ts-ignore
        Object.keys(StakeManager.events).forEach(function (topic) {
            // @ts-ignore
            Penalizer.network.events[topic] = StakeManager.events[topic];
        });
    });
    async function prepareRelayCall() {
        const gasPrice = new bn_js_1.default('1');
        const gasLimit = new bn_js_1.default('5000000');
        const txData = recipient.contract.methods.emitMessage('').encodeABI();
        const relayRequest = {
            request: {
                to: recipient.address,
                data: txData,
                from: sender,
                nonce: '0',
                value: '0',
                gas: gasLimit.toString()
            },
            relayData: {
                gasPrice: gasPrice.toString(),
                baseRelayFee: '300',
                pctRelayFee: '10',
                relayWorker,
                forwarder,
                paymaster: paymaster.address,
                paymasterData,
                clientId
            }
        };
        const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequest);
        const signature = await Utils_1.getEip712Signature(web3, dataToSign);
        return {
            gasPrice,
            gasLimit,
            relayRequest,
            signature
        };
    }
    describe('penalizations', function () {
        const reporter = other;
        const stake = test_helpers_1.ether('1');
        // Receives a function that will penalize the relay and tests that call for a penalization, including checking the
        // emitted event and penalization reward transfer. Returns the transaction receipt.
        async function expectPenalization(penalizeWithOpts) {
            const reporterBalanceTracker = await test_helpers_1.balance.tracker(reporter);
            const stakeManagerBalanceTracker = await test_helpers_1.balance.tracker(stakeManager.address);
            const stakeInfo = await stakeManager.stakes(relayManager);
            // @ts-ignore (names)
            const stake = stakeInfo.stake;
            const expectedReward = stake.divn(2);
            // A gas price of zero makes checking the balance difference simpler
            const receipt = await penalizeWithOpts({
                from: reporter,
                gasPrice: 0
            });
            test_helpers_1.expectEvent.inLogs(receipt.logs, 'StakePenalized', {
                relayManager: relayManager,
                beneficiary: reporter,
                reward: expectedReward
            });
            // The reporter gets half of the stake
            chai_1.expect(await reporterBalanceTracker.delta()).to.be.bignumber.equals(stake.divn(2));
            // The other half is burned, so RelayHub's balance is decreased by the full stake
            chai_1.expect(await stakeManagerBalanceTracker.delta()).to.be.bignumber.equals(stake.neg());
            return receipt;
        }
        describe('penalizable behaviors', function () {
            const encodedCallArgs = {
                sender,
                recipient: '0x1820b744B33945482C17Dc37218C01D858EBc714',
                data: '0x1234',
                baseFee: 1000,
                fee: 10,
                gasPrice: 50,
                gasLimit: 1000000,
                nonce: 0,
                paymaster: ''
            };
            const relayCallArgs = {
                gasPrice: 50,
                gasLimit: 1000000,
                nonce: 0,
                privateKey: '6370fd033278c143179d81c5526140625662b8daa446c22ee2d73db3707e620c' // relay's private key
            };
            before(function () {
                // @ts-ignore
                chai_1.expect('0x' + ethereumjs_util_1.privateToAddress('0x' + relayCallArgs.privateKey).toString('hex')).to.equal(relayWorker.toLowerCase());
                // TODO: I don't want to refactor everything here, but this value is not available before 'before' is run :-(
                encodedCallArgs.paymaster = paymaster.address;
            });
            beforeEach('staking for relay', async function () {
                await stakeManager.stakeForAddress(relayManager, 1000, {
                    value: stake,
                    from: relayOwner
                });
                await stakeManager.authorizeHubByOwner(relayManager, relayHub.address, { from: relayOwner });
            });
            describe('repeated relay nonce', function () {
                it('penalizes transactions with same nonce and different data', async function () {
                    const txDataSigA = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, relayCallArgs), chainId);
                    const txDataSigB = getDataAndSignature(encodeRelayCallEIP155(Object.assign({}, encodedCallArgs, { data: '0xabcd' }), relayCallArgs), chainId);
                    await expectPenalization(async (opts) => await penalizer.penalizeRepeatedNonce(txDataSigA.data, txDataSigA.signature, txDataSigB.data, txDataSigB.signature, relayHub.address, opts));
                });
                it('penalizes transactions with same nonce and different gas limit', async function () {
                    const txDataSigA = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, relayCallArgs), chainId);
                    const txDataSigB = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, Object.assign({}, relayCallArgs, { gasLimit: 100 })), chainId);
                    await expectPenalization(async (opts) => await penalizer.penalizeRepeatedNonce(txDataSigA.data, txDataSigA.signature, txDataSigB.data, txDataSigB.signature, relayHub.address, opts));
                });
                it('penalizes transactions with same nonce and different value', async function () {
                    const txDataSigA = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, relayCallArgs), chainId);
                    const txDataSigB = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, Object.assign({}, relayCallArgs, { value: 100 })), chainId);
                    await expectPenalization(async (opts) => await penalizer.penalizeRepeatedNonce(txDataSigA.data, txDataSigA.signature, txDataSigB.data, txDataSigB.signature, relayHub.address, opts));
                });
                it('does not penalize transactions with same nonce and data, value, gasLimit, destination', async function () {
                    const txDataSigA = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, relayCallArgs), chainId);
                    const txDataSigB = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, Object.assign({}, relayCallArgs, { gasPrice: 70 }) // only gasPrice may be different
                    ), chainId);
                    await test_helpers_1.expectRevert(penalizer.penalizeRepeatedNonce(txDataSigA.data, txDataSigA.signature, txDataSigB.data, txDataSigB.signature, relayHub.address), 'tx is equal');
                });
                it('does not penalize transactions with different nonces', async function () {
                    const txDataSigA = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, relayCallArgs), chainId);
                    const txDataSigB = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, Object.assign({}, relayCallArgs, { nonce: 1 })), chainId);
                    await test_helpers_1.expectRevert(penalizer.penalizeRepeatedNonce(txDataSigA.data, txDataSigA.signature, txDataSigB.data, txDataSigB.signature, relayHub.address), 'Different nonce');
                });
                it('does not penalize transactions with same nonce from different relays', async function () {
                    const txDataSigA = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, relayCallArgs), chainId);
                    const txDataSigB = getDataAndSignature(encodeRelayCallEIP155(encodedCallArgs, Object.assign({}, relayCallArgs, { privateKey: '0123456789012345678901234567890123456789012345678901234567890123' })), chainId);
                    await test_helpers_1.expectRevert(penalizer.penalizeRepeatedNonce(txDataSigA.data, txDataSigA.signature, txDataSigB.data, txDataSigB.signature, relayHub.address), 'Different signer');
                });
            });
            describe('illegal call', function () {
                // TODO: this tests are excessive, and have a lot of tedious build-up
                it('penalizes relay transactions to addresses other than RelayHub', async function () {
                    // Relay sending ether to another account
                    const { transactionHash } = await test_helpers_1.send.ether(relayWorker, other, test_helpers_1.ether('0.5'));
                    const { data, signature } = await getDataAndSignatureFromHash(transactionHash, chainId);
                    await expectPenalization(async (opts) => await penalizer.penalizeIllegalTransaction(data, signature, relayHub.address, opts));
                });
                it('penalizes relay worker transactions to illegal RelayHub functions (stake)', async function () {
                    // Relay staking for a second relay
                    const { tx } = await stakeManager.stakeForAddress(other, 1000, {
                        value: test_helpers_1.ether('1'),
                        from: relayWorker
                    });
                    const { data, signature } = await getDataAndSignatureFromHash(tx, chainId);
                    await expectPenalization(async (opts) => await penalizer.penalizeIllegalTransaction(data, signature, relayHub.address, opts));
                });
                it('penalizes relay worker transactions to illegal RelayHub functions (penalize)', async function () {
                    // A second relay is registered
                    await stakeManager.stakeForAddress(otherRelayManager, 1000, {
                        value: test_helpers_1.ether('1'),
                        from: relayOwner
                    });
                    await stakeManager.authorizeHubByOwner(otherRelayManager, relayHub.address, { from: relayOwner });
                    await relayHub.addRelayWorkers([otherRelayWorker], { from: otherRelayManager });
                    // An illegal transaction is sent by it
                    const stakeTx = await test_helpers_1.send.ether(otherRelayWorker, other, test_helpers_1.ether('0.5'));
                    // A relay penalizes it
                    const stakeTxDataSig = await getDataAndSignatureFromHash(stakeTx.transactionHash, chainId);
                    const penalizeTx = await penalizer.penalizeIllegalTransaction(stakeTxDataSig.data, stakeTxDataSig.signature, relayHub.address, { from: relayWorker });
                    // It can now be penalized for that
                    const penalizeTxDataSig = await getDataAndSignatureFromHash(penalizeTx.tx, chainId);
                    await expectPenalization(async (opts) => await penalizer.penalizeIllegalTransaction(penalizeTxDataSig.data, penalizeTxDataSig.signature, relayHub.address, opts));
                });
                it('should penalize relays for lying about transaction gas limit RelayHub', async function () {
                    const { gasPrice, gasLimit, relayRequest, signature } = await prepareRelayCall();
                    await relayHub.depositFor(paymaster.address, {
                        from: other,
                        value: test_helpers_1.ether('1')
                    });
                    const relayCallTx = await relayHub.relayCall(relayRequest, signature, '0x', gasLimit.add(new bn_js_1.default(2e6)), {
                        from: relayWorker,
                        gas: gasLimit.add(new bn_js_1.default(1e6)),
                        gasPrice
                    });
                    const relayCallTxDataSig = await getDataAndSignatureFromHash(relayCallTx.tx, chainId);
                    await expectPenalization(async (opts) => await penalizer.penalizeIllegalTransaction(relayCallTxDataSig.data, relayCallTxDataSig.signature, relayHub.address, opts));
                });
                it('does not penalize legal relay transactions', async function () {
                    // relayCall is a legal transaction
                    const baseFee = new bn_js_1.default('300');
                    const fee = new bn_js_1.default('10');
                    const gasPrice = new bn_js_1.default('1');
                    const gasLimit = new bn_js_1.default('1000000');
                    const senderNonce = new bn_js_1.default('0');
                    const txData = recipient.contract.methods.emitMessage('').encodeABI();
                    const relayRequest = {
                        request: {
                            to: recipient.address,
                            data: txData,
                            from: sender,
                            nonce: senderNonce.toString(),
                            value: '0',
                            gas: gasLimit.toString()
                        },
                        relayData: {
                            gasPrice: gasPrice.toString(),
                            baseRelayFee: baseFee.toString(),
                            pctRelayFee: fee.toString(),
                            relayWorker,
                            forwarder,
                            paymaster: paymaster.address,
                            paymasterData,
                            clientId
                        }
                    };
                    const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequest);
                    const signature = await Utils_1.getEip712Signature(web3, dataToSign);
                    await relayHub.depositFor(paymaster.address, {
                        from: other,
                        value: test_helpers_1.ether('1')
                    });
                    const externalGasLimit = gasLimit.add(new bn_js_1.default(1e6));
                    const relayCallTx = await relayHub.relayCall(relayRequest, signature, '0x', externalGasLimit, {
                        from: relayWorker,
                        gas: externalGasLimit,
                        gasPrice
                    });
                    const relayCallTxDataSig = await getDataAndSignatureFromHash(relayCallTx.tx, chainId);
                    await test_helpers_1.expectRevert(penalizer.penalizeIllegalTransaction(relayCallTxDataSig.data, relayCallTxDataSig.signature, relayHub.address), 'Legal relay transaction');
                });
            });
        });
        describe('penalizable relay states', function () {
            context('with penalizable transaction', function () {
                let penalizableTxData;
                let penalizableTxSignature;
                beforeEach(async function () {
                    // Relays are not allowed to transfer Ether
                    const { transactionHash } = await test_helpers_1.send.ether(thirdRelayWorker, other, test_helpers_1.ether('0.5'));
                    ({
                        data: penalizableTxData,
                        signature: penalizableTxSignature
                    } = await getDataAndSignatureFromHash(transactionHash, chainId));
                });
                // All of these tests use the same penalization function (we one we set up in the beforeEach block)
                async function penalize() {
                    return await expectPenalization(async (opts) => await penalizer.penalizeIllegalTransaction(penalizableTxData, penalizableTxSignature, relayHub.address, opts));
                }
                context('with not owned relay worker', function () {
                    it('account cannot be penalized', async function () {
                        await test_helpers_1.expectRevert(penalize(), 'Unknown relay worker');
                    });
                });
                context('with staked and locked relay manager and ', function () {
                    beforeEach(async function () {
                        await stakeManager.stakeForAddress(relayManager, 1000, {
                            from: relayOwner,
                            value: test_helpers_1.ether('1')
                        });
                    });
                    before(async function () {
                        await stakeManager.authorizeHubByOwner(relayManager, relayHub.address, { from: relayOwner });
                        await relayHub.addRelayWorkers([thirdRelayWorker], { from: relayManager });
                    });
                    it('relay can be penalized', async function () {
                        await penalize();
                    });
                    it('relay cannot be penalized twice', async function () {
                        await penalize();
                        await test_helpers_1.expectRevert(penalize(), 'relay manager not staked');
                    });
                });
            });
        });
        function encodeRelayCallEIP155(encodedCallArgs, relayCallArgs) {
            const privateKey = Buffer.from(relayCallArgs.privateKey, 'hex');
            const relayWorker = ethereumjs_util_1.privateToAddress(privateKey).toString('hex');
            // TODO: 'encodedCallArgs' is no longer needed. just keep the RelayRequest in test
            const relayRequest = {
                request: {
                    to: encodedCallArgs.recipient,
                    data: encodedCallArgs.data,
                    from: encodedCallArgs.sender,
                    nonce: encodedCallArgs.nonce.toString(),
                    value: '0',
                    gas: encodedCallArgs.gasLimit.toString()
                },
                relayData: {
                    baseRelayFee: encodedCallArgs.baseFee.toString(),
                    pctRelayFee: encodedCallArgs.fee.toString(),
                    gasPrice: encodedCallArgs.gasPrice.toString(),
                    relayWorker,
                    forwarder,
                    paymaster: encodedCallArgs.paymaster,
                    paymasterData,
                    clientId
                }
            };
            const encodedCall = relayHub.contract.methods.relayCall(relayRequest, '0xabcdef123456', '0x', 4e6).encodeABI();
            const transaction = new ethereumjs_tx_1.Transaction({
                nonce: relayCallArgs.nonce,
                gasLimit: relayCallArgs.gasLimit,
                gasPrice: relayCallArgs.gasPrice,
                to: relayHub.address,
                value: relayCallArgs.value,
                // @ts-ignore
                chainId: 1,
                data: encodedCall
            });
            transaction.sign(Buffer.from(relayCallArgs.privateKey, 'hex'));
            return transaction;
        }
        async function getDataAndSignatureFromHash(txHash, chainId) {
            // @ts-ignore
            const rpcTx = await web3.eth.getTransaction(txHash);
            // eslint: this is stupid how many checks for 0 there are
            // @ts-ignore
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!chainId && parseInt(rpcTx.v, 16) > 28) {
                throw new Error('Missing ChainID for EIP-155 signature');
            }
            // @ts-ignore
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (chainId && parseInt(rpcTx.v, 16) <= 28) {
                throw new Error('Passed ChainID for non-EIP-155 signature');
            }
            // @ts-ignore
            const tx = new ethereumjs_tx_1.Transaction({
                nonce: new bn_js_1.default(rpcTx.nonce),
                gasPrice: new bn_js_1.default(rpcTx.gasPrice),
                gasLimit: new bn_js_1.default(rpcTx.gas),
                to: rpcTx.to,
                value: new bn_js_1.default(rpcTx.value),
                data: rpcTx.input,
                // @ts-ignore
                v: rpcTx.v,
                // @ts-ignore
                r: rpcTx.r,
                // @ts-ignore
                s: rpcTx.s
            });
            return getDataAndSignature(tx, chainId);
        }
        function getDataAndSignature(tx, chainId) {
            const input = [tx.nonce, tx.gasPrice, tx.gasLimit, tx.to, tx.value, tx.data];
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (chainId) {
                input.push(ethereumjs_util_1.toBuffer(chainId), ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(0)), ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(0)));
            }
            let v = tx.v[0];
            if (v > 28) {
                v -= chainId * 2 + 8;
            }
            const data = `0x${rlp_1.encode(input).toString('hex')}`;
            const signature = `0x${'00'.repeat(32 - tx.r.length) + tx.r.toString('hex')}${'00'.repeat(32 - tx.s.length) + tx.s.toString('hex')}${v.toString(16)}`;
            return {
                data,
                signature
            };
        }
    });
});
//# sourceMappingURL=RelayHubPenalizations.test.js.map