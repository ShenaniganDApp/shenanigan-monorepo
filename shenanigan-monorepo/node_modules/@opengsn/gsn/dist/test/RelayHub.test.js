"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@openzeppelin/test-helpers");
const bn_js_1 = __importDefault(require("bn.js"));
const chai_1 = require("chai");
const Utils_1 = require("../src/common/Utils");
const RelayRequest_1 = require("../src/common/EIP712/RelayRequest");
const Environments_1 = require("../src/common/Environments");
const TypedRequestData_1 = __importStar(require("../src/common/EIP712/TypedRequestData"));
const TestUtils_1 = require("./TestUtils");
const StakeManager = artifacts.require('StakeManager');
const Forwarder = artifacts.require('Forwarder');
const Penalizer = artifacts.require('Penalizer');
const TestPaymasterEverythingAccepted = artifacts.require('TestPaymasterEverythingAccepted');
const TestRecipient = artifacts.require('TestRecipient');
const TestPaymasterStoreContext = artifacts.require('TestPaymasterStoreContext');
const TestPaymasterConfigurableMisbehavior = artifacts.require('TestPaymasterConfigurableMisbehavior');
contract('RelayHub', function ([_, relayOwner, relayManager, relayWorker, senderAddress, other, dest, incorrectWorker]) {
    const RelayCallStatusCodes = {
        OK: new bn_js_1.default('0'),
        RelayedCallFailed: new bn_js_1.default('1'),
        PreRelayedFailed: new bn_js_1.default('2'),
        PostRelayedFailed: new bn_js_1.default('3'),
        RecipientBalanceChanged: new bn_js_1.default('4')
    };
    const chainId = Environments_1.defaultEnvironment.chainId;
    let relayHub;
    let stakeManager;
    let penalizer;
    let relayHubInstance;
    let recipientContract;
    let paymasterContract;
    let forwarderInstance;
    let target;
    let paymaster;
    let forwarder;
    beforeEach(async function () {
        stakeManager = await StakeManager.new();
        penalizer = await Penalizer.new();
        relayHubInstance = await TestUtils_1.deployHub(stakeManager.address, penalizer.address);
        paymasterContract = await TestPaymasterEverythingAccepted.new();
        forwarderInstance = await Forwarder.new();
        forwarder = forwarderInstance.address;
        recipientContract = await TestRecipient.new(forwarder);
        // register hub's RelayRequest with forwarder, if not already done.
        await forwarderInstance.registerRequestType(TypedRequestData_1.GsnRequestType.typeName, TypedRequestData_1.GsnRequestType.typeSuffix);
        target = recipientContract.address;
        paymaster = paymasterContract.address;
        relayHub = relayHubInstance.address;
        await paymasterContract.setRelayHub(relayHub);
    });
    it('should retrieve version number', async function () {
        const version = await relayHubInstance.versionHub();
        assert.match(version, /2\.\d*\.\d*-?.*\+opengsn\.hub\.irelayhub/);
    });
    describe('balances', function () {
        async function testDeposit(sender, paymaster, amount) {
            const senderBalanceTracker = await test_helpers_1.balance.tracker(sender);
            const relayHubBalanceTracker = await test_helpers_1.balance.tracker(relayHub);
            const { logs } = await relayHubInstance.depositFor(paymaster, {
                from: sender,
                value: amount,
                gasPrice: 0
            });
            test_helpers_1.expectEvent.inLogs(logs, 'Deposited', {
                paymaster,
                from: sender,
                amount
            });
            chai_1.expect(await relayHubInstance.balanceOf(paymaster)).to.be.bignumber.equal(amount);
            chai_1.expect(await senderBalanceTracker.delta()).to.be.bignumber.equal(amount.neg());
            chai_1.expect(await relayHubBalanceTracker.delta()).to.be.bignumber.equal(amount);
        }
        it('can deposit for self', async function () {
            await testDeposit(other, other, test_helpers_1.ether('1'));
        });
        it('can deposit for others', async function () {
            await testDeposit(other, target, test_helpers_1.ether('1'));
        });
        it('cannot deposit amounts larger than the limit', async function () {
            await test_helpers_1.expectRevert(relayHubInstance.depositFor(target, {
                from: other,
                value: test_helpers_1.ether('3'),
                gasPrice: 0
            }), 'deposit too big');
        });
        it('can deposit multiple times and have a total deposit larger than the limit', async function () {
            await relayHubInstance.depositFor(target, {
                from: other,
                value: test_helpers_1.ether('1'),
                gasPrice: 0
            });
            await relayHubInstance.depositFor(target, {
                from: other,
                value: test_helpers_1.ether('1'),
                gasPrice: 0
            });
            await relayHubInstance.depositFor(target, {
                from: other,
                value: test_helpers_1.ether('1'),
                gasPrice: 0
            });
            chai_1.expect(await relayHubInstance.balanceOf(target)).to.be.bignumber.equals(test_helpers_1.ether('3'));
        });
        it('accounts with deposits can withdraw partially', async function () {
            const amount = test_helpers_1.ether('1');
            await testDeposit(other, other, amount);
            const { logs } = await relayHubInstance.withdraw(amount.divn(2), dest, { from: other });
            test_helpers_1.expectEvent.inLogs(logs, 'Withdrawn', {
                account: other,
                dest,
                amount: amount.divn(2)
            });
        });
        it('accounts with deposits can withdraw all their balance', async function () {
            const amount = test_helpers_1.ether('1');
            await testDeposit(other, other, amount);
            const { logs } = await relayHubInstance.withdraw(amount, dest, { from: other });
            test_helpers_1.expectEvent.inLogs(logs, 'Withdrawn', {
                account: other,
                dest,
                amount
            });
        });
        it('accounts cannot withdraw more than their balance', async function () {
            const amount = test_helpers_1.ether('1');
            await testDeposit(other, other, amount);
            await test_helpers_1.expectRevert(relayHubInstance.withdraw(amount.addn(1), dest, { from: other }), 'insufficient funds');
        });
    });
    describe('relayCall', function () {
        const baseRelayFee = '10000';
        const pctRelayFee = '10';
        const gasPrice = '10';
        const gasLimit = '1000000';
        const senderNonce = '0';
        let sharedRelayRequestData;
        const paymasterData = '0x';
        const clientId = '1';
        beforeEach(function () {
            sharedRelayRequestData = {
                request: {
                    to: target,
                    data: '',
                    from: senderAddress,
                    nonce: senderNonce,
                    value: '0',
                    gas: gasLimit
                },
                relayData: {
                    pctRelayFee,
                    baseRelayFee,
                    gasPrice,
                    relayWorker,
                    forwarder,
                    paymaster,
                    paymasterData,
                    clientId
                }
            };
        });
        context('with unknown worker', function () {
            const signature = '0xdeadbeef';
            const approvalData = '0x';
            const gas = 4e6;
            let relayRequest;
            beforeEach(async function () {
                relayRequest = RelayRequest_1.cloneRelayRequest(sharedRelayRequestData);
                relayRequest.request.data = '0xdeadbeef';
                await relayHubInstance.depositFor(paymaster, {
                    from: other,
                    value: test_helpers_1.ether('1'),
                    gasPrice: 0
                });
            });
            it('should not accept a relay call', async function () {
                await test_helpers_1.expectRevert(relayHubInstance.relayCall(relayRequest, signature, approvalData, gas, {
                    from: relayWorker,
                    gas
                }), 'Unknown relay worker');
            });
            context('with manager stake unlocked', function () {
                beforeEach(async function () {
                    await stakeManager.stakeForAddress(relayManager, 1000, {
                        value: test_helpers_1.ether('1'),
                        from: relayOwner
                    });
                    await stakeManager.authorizeHubByOwner(relayManager, relayHub, { from: relayOwner });
                    await relayHubInstance.addRelayWorkers([relayWorker], {
                        from: relayManager
                    });
                    await stakeManager.unauthorizeHubByOwner(relayManager, relayHub, { from: relayOwner });
                });
                it('should not accept a relay call', async function () {
                    await test_helpers_1.expectRevert(relayHubInstance.relayCall(relayRequest, signature, approvalData, gas, {
                        from: relayWorker,
                        gas
                    }), 'relay manager not staked');
                });
            });
        });
        context('with staked and registered relay', function () {
            const url = 'http://relay.com';
            const message = 'GSN RelayHub';
            const messageWithNoParams = 'Method with no parameters';
            let relayRequest;
            let encodedFunction;
            let signatureWithPermissivePaymaster;
            beforeEach(async function () {
                await stakeManager.stakeForAddress(relayManager, 1000, {
                    value: test_helpers_1.ether('2'),
                    from: relayOwner
                });
                await stakeManager.authorizeHubByOwner(relayManager, relayHub, { from: relayOwner });
                // truffle-contract doesn't let us create method data from the class, we need an actual instance
                encodedFunction = recipientContract.contract.methods.emitMessage(message).encodeABI();
                await relayHubInstance.addRelayWorkers([relayWorker], { from: relayManager });
                await relayHubInstance.registerRelayServer(baseRelayFee, pctRelayFee, url, { from: relayManager });
                relayRequest = RelayRequest_1.cloneRelayRequest(sharedRelayRequestData);
                relayRequest.request.data = encodedFunction;
                const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequest);
                signatureWithPermissivePaymaster = await Utils_1.getEip712Signature(web3, dataToSign);
                await relayHubInstance.depositFor(paymaster, {
                    value: test_helpers_1.ether('1'),
                    from: other
                });
            });
            context('with relay worker that is not externally-owned account', function () {
                it('should not accept relay requests', async function () {
                    const signature = '0xdeadbeef';
                    const gas = 4e6;
                    const TestRelayWorkerContract = artifacts.require('TestRelayWorkerContract');
                    const testRelayWorkerContract = await TestRelayWorkerContract.new();
                    await relayHubInstance.addRelayWorkers([testRelayWorkerContract.address], {
                        from: relayManager
                    });
                    await test_helpers_1.expectRevert(testRelayWorkerContract.relayCall(relayHubInstance.address, relayRequest, signature, gas, {
                        gas
                    }), 'relay worker cannot be a smart contract');
                });
            });
            context('with view functions only', function () {
                let misbehavingPaymaster;
                let relayRequestMisbehavingPaymaster;
                beforeEach(async function () {
                    misbehavingPaymaster = await TestPaymasterConfigurableMisbehavior.new();
                    await misbehavingPaymaster.setRelayHub(relayHub);
                    await relayHubInstance.depositFor(misbehavingPaymaster.address, {
                        value: test_helpers_1.ether('1'),
                        from: other
                    });
                    relayRequestMisbehavingPaymaster = RelayRequest_1.cloneRelayRequest(relayRequest);
                    relayRequestMisbehavingPaymaster.relayData.paymaster = misbehavingPaymaster.address;
                });
                it('should get \'paymasterAccepted = true\' and no revert reason as view call result of \'relayCall\' for a valid transaction', async function () {
                    const relayCallView = await relayHubInstance.contract.methods.relayCall(relayRequest, signatureWithPermissivePaymaster, '0x', 7e6)
                        .call({
                        from: relayWorker,
                        gas: 7e6
                    });
                    assert.equal(relayCallView.revertReason, '');
                    assert.equal(relayCallView.paymasterAccepted, true);
                });
                it('should get Paymaster\'s reject reason from view call result of \'relayCall\' for a transaction with a wrong signature', async function () {
                    await misbehavingPaymaster.setReturnInvalidErrorCode(true);
                    const relayCallView = await relayHubInstance.contract.methods
                        .relayCall(relayRequestMisbehavingPaymaster, '0x', '0x', 7e6)
                        .call({ from: relayWorker });
                    assert.equal(relayCallView.paymasterAccepted, false);
                    assert.equal(relayCallView.revertReason, 'invalid code');
                });
            });
            context('with funded paymaster', function () {
                let signature;
                let paymasterWithContext;
                let misbehavingPaymaster;
                let relayRequestPaymasterWithContext;
                let signatureWithContextPaymaster;
                let signatureWithMisbehavingPaymaster;
                let relayRequestMisbehavingPaymaster;
                const gas = 4e6;
                beforeEach(async function () {
                    paymasterWithContext = await TestPaymasterStoreContext.new();
                    misbehavingPaymaster = await TestPaymasterConfigurableMisbehavior.new();
                    await paymasterWithContext.setRelayHub(relayHub);
                    await misbehavingPaymaster.setRelayHub(relayHub);
                    await relayHubInstance.depositFor(paymasterWithContext.address, {
                        value: test_helpers_1.ether('1'),
                        from: other
                    });
                    await relayHubInstance.depositFor(misbehavingPaymaster.address, {
                        value: test_helpers_1.ether('1'),
                        from: other
                    });
                    let dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequest);
                    signature = await Utils_1.getEip712Signature(web3, dataToSign);
                    relayRequestMisbehavingPaymaster = RelayRequest_1.cloneRelayRequest(relayRequest);
                    relayRequestMisbehavingPaymaster.relayData.paymaster = misbehavingPaymaster.address;
                    dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequestMisbehavingPaymaster);
                    signatureWithMisbehavingPaymaster = await Utils_1.getEip712Signature(web3, dataToSign);
                    relayRequestPaymasterWithContext = RelayRequest_1.cloneRelayRequest(relayRequest);
                    relayRequestPaymasterWithContext.relayData.paymaster = paymasterWithContext.address;
                    dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequestPaymasterWithContext);
                    signatureWithContextPaymaster = await Utils_1.getEip712Signature(web3, dataToSign);
                });
                it('relayCall executes the transaction and increments sender nonce on hub', async function () {
                    const nonceBefore = await forwarderInstance.getNonce(senderAddress);
                    const { tx, logs } = await relayHubInstance.relayCall(relayRequest, signatureWithPermissivePaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice
                    });
                    const nonceAfter = await forwarderInstance.getNonce(senderAddress);
                    assert.equal(nonceBefore.addn(1).toNumber(), nonceAfter.toNumber());
                    await test_helpers_1.expectEvent.inTransaction(tx, TestRecipient, 'SampleRecipientEmitted', {
                        message,
                        realSender: senderAddress,
                        msgSender: forwarder,
                        origin: relayWorker
                    });
                    const expectedReturnValue = web3.eth.abi.encodeParameter('string', 'emitMessage return value');
                    test_helpers_1.expectEvent.inLogs(logs, 'TransactionRelayed', {
                        status: RelayCallStatusCodes.OK,
                        returnValue: expectedReturnValue
                    });
                });
                // This test is added due to a regression that almost slipped to production.
                it('relayCall executes the transaction with no parameters', async function () {
                    const encodedFunction = recipientContract.contract.methods.emitMessageNoParams().encodeABI();
                    const relayRequestNoCallData = RelayRequest_1.cloneRelayRequest(relayRequest);
                    relayRequestNoCallData.request.data = encodedFunction;
                    const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequestNoCallData);
                    signature = await Utils_1.getEip712Signature(web3, dataToSign);
                    const { tx } = await relayHubInstance.relayCall(relayRequestNoCallData, signature, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice
                    });
                    await test_helpers_1.expectEvent.inTransaction(tx, TestRecipient, 'SampleRecipientEmitted', {
                        message: messageWithNoParams,
                        realSender: senderAddress,
                        msgSender: forwarder,
                        origin: relayWorker
                    });
                });
                it('relayCall executes a transaction even if recipient call reverts', async function () {
                    const encodedFunction = recipientContract.contract.methods.testRevert().encodeABI();
                    const relayRequestRevert = RelayRequest_1.cloneRelayRequest(relayRequest);
                    relayRequestRevert.request.data = encodedFunction;
                    const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequestRevert);
                    signature = await Utils_1.getEip712Signature(web3, dataToSign);
                    const { logs } = await relayHubInstance.relayCall(relayRequestRevert, signature, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice
                    });
                    const expectedReturnValue = '0x08c379a0' + Utils_1.removeHexPrefix(web3.eth.abi.encodeParameter('string', 'always fail'));
                    test_helpers_1.expectEvent.inLogs(logs, 'TransactionRelayed', {
                        status: RelayCallStatusCodes.RelayedCallFailed,
                        returnValue: expectedReturnValue
                    });
                });
                it('preRelayedCall receives values returned in acceptRelayedCall', async function () {
                    const { tx } = await relayHubInstance.relayCall(relayRequestPaymasterWithContext, signatureWithContextPaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice
                    });
                    await test_helpers_1.expectEvent.inTransaction(tx, TestPaymasterStoreContext, 'SampleRecipientPreCallWithValues', {
                        relay: relayWorker,
                        from: senderAddress,
                        encodedFunction,
                        baseRelayFee,
                        pctRelayFee,
                        gasPrice,
                        gasLimit,
                        nonce: senderNonce,
                        approvalData: null
                    });
                });
                it('postRelayedCall receives values returned in acceptRelayedCall', async function () {
                    const { tx } = await relayHubInstance.relayCall(relayRequestPaymasterWithContext, signatureWithContextPaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice
                    });
                    await test_helpers_1.expectEvent.inTransaction(tx, TestPaymasterStoreContext, 'SampleRecipientPostCallWithValues', {
                        relay: relayWorker,
                        from: senderAddress,
                        encodedFunction,
                        baseRelayFee,
                        pctRelayFee,
                        gasPrice,
                        gasLimit,
                        nonce: senderNonce,
                        approvalData: null
                    });
                });
                it('relaying is aborted if the paymaster reverts the acceptRelayedCall', async function () {
                    await misbehavingPaymaster.setReturnInvalidErrorCode(true);
                    const { logs } = await relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signatureWithMisbehavingPaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice
                    });
                    test_helpers_1.expectEvent.inLogs(logs, 'TransactionRejectedByPaymaster', { reason: 'invalid code' });
                });
                it('should not accept relay requests if gas limit is too low for a relayed transaction', async function () {
                    // Adding gasReserve is not enough by a few wei as some gas is spent before gasleft().
                    const gasReserve = 99999;
                    const gas = parseInt(gasLimit) + gasReserve;
                    await test_helpers_1.expectRevert(relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signatureWithMisbehavingPaymaster, '0x', gas, {
                        from: relayWorker,
                        gasPrice,
                        gas
                    }), 'Not enough gas left for innerRelayCall to complete');
                });
                it('should not accept relay requests with gas price lower then user specified', async function () {
                    await test_helpers_1.expectRevert(relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signatureWithMisbehavingPaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice: parseInt(gasPrice) - 1
                    }), 'Invalid gas price');
                });
                it('should not accept relay requests with gas limit higher then block gas limit', async function () {
                    await test_helpers_1.expectRevert(relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signatureWithMisbehavingPaymaster, '0x', 100000001, {
                        from: relayWorker,
                        gasPrice,
                        gas
                    }), 'Impossible gas limit');
                });
                it('should not accept relay requests with incorrect relay worker', async function () {
                    await relayHubInstance.addRelayWorkers([incorrectWorker], { from: relayManager });
                    await test_helpers_1.expectRevert(relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signatureWithMisbehavingPaymaster, '0x', gas, {
                        from: incorrectWorker,
                        gasPrice,
                        gas
                    }), 'Not a right worker');
                });
                it('should not accept relay requests if destination recipient doesn\'t have a balance to pay for it', async function () {
                    const paymaster2 = await TestPaymasterEverythingAccepted.new();
                    await paymaster2.setRelayHub(relayHub);
                    const maxPossibleCharge = (await relayHubInstance.calculateCharge(gasLimit, {
                        gasPrice,
                        pctRelayFee,
                        baseRelayFee,
                        relayWorker,
                        forwarder,
                        paymaster: paymaster2.address,
                        paymasterData: '0x',
                        clientId: '1'
                    })).toNumber();
                    await paymaster2.deposit({ value: (maxPossibleCharge - 1).toString() }); // TODO: replace with correct margin calculation
                    const relayRequestPaymaster2 = RelayRequest_1.cloneRelayRequest(relayRequest);
                    relayRequestPaymaster2.relayData.paymaster = paymaster2.address;
                    await test_helpers_1.expectRevert(relayHubInstance.relayCall(relayRequestPaymaster2, signatureWithMisbehavingPaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice
                    }), 'Paymaster balance too low');
                });
                it('should not execute the \'relayedCall\' if \'preRelayedCall\' reverts', async function () {
                    await misbehavingPaymaster.setRevertPreRelayCall(true);
                    // @ts-ignore (there is a problem with web3 types annotations that must be solved)
                    const startBlock = await web3.eth.getBlockNumber();
                    const { logs } = await relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signatureWithMisbehavingPaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice: gasPrice
                    });
                    // There should not be an event emitted, which means the result of 'relayCall' was indeed reverted
                    const logsMessages = await recipientContract.contract.getPastEvents('SampleRecipientEmitted', {
                        fromBlock: startBlock,
                        toBlock: 'latest'
                    });
                    assert.equal(0, logsMessages.length);
                    const expectedReturnValue = '0x08c379a0' + Utils_1.removeHexPrefix(web3.eth.abi.encodeParameter('string', 'You asked me to revert, remember?'));
                    test_helpers_1.expectEvent.inLogs(logs, 'TransactionRelayed', {
                        status: RelayCallStatusCodes.PreRelayedFailed,
                        returnValue: expectedReturnValue
                    });
                });
                it('should revert the \'relayedCall\' if \'postRelayedCall\' reverts', async function () {
                    await misbehavingPaymaster.setRevertPostRelayCall(true);
                    const { logs } = await relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signatureWithMisbehavingPaymaster, '0x', gas, {
                        from: relayWorker,
                        gas,
                        gasPrice: gasPrice
                    });
                    // @ts-ignore (there is a problem with web3 types annotations that must be solved)
                    const startBlock = await web3.eth.getBlockNumber();
                    // There should not be an event emitted, which means the result of 'relayCall' was indeed reverted
                    const logsMessages = await recipientContract.contract.getPastEvents('SampleRecipientEmitted', {
                        fromBlock: startBlock,
                        toBlock: 'latest'
                    });
                    assert.equal(0, logsMessages.length);
                    test_helpers_1.expectEvent.inLogs(logs, 'TransactionRelayed', { status: RelayCallStatusCodes.PostRelayedFailed });
                });
                describe('recipient balance withdrawal ban', function () {
                    let misbehavingPaymaster;
                    let relayRequestMisbehavingPaymaster;
                    let signature;
                    beforeEach(async function () {
                        misbehavingPaymaster = await TestPaymasterConfigurableMisbehavior.new();
                        await misbehavingPaymaster.setRelayHub(relayHub);
                        await relayHubInstance.depositFor(misbehavingPaymaster.address, {
                            value: test_helpers_1.ether('1'),
                            from: other
                        });
                        relayRequestMisbehavingPaymaster = RelayRequest_1.cloneRelayRequest(relayRequest);
                        relayRequestMisbehavingPaymaster.relayData.paymaster = misbehavingPaymaster.address;
                        const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequestMisbehavingPaymaster);
                        signature = await Utils_1.getEip712Signature(web3, dataToSign);
                    });
                    it('reverts relayed call if recipient withdraws balance during preRelayedCall', async function () {
                        await misbehavingPaymaster.setWithdrawDuringPreRelayedCall(true);
                        await assertRevertWithRecipientBalanceChanged();
                    });
                    it('reverts relayed call if recipient withdraws balance during the relayed call', async function () {
                        await recipientContract.setWithdrawDuringRelayedCall(misbehavingPaymaster.address);
                        await assertRevertWithRecipientBalanceChanged();
                    });
                    it('reverts relayed call if recipient withdraws balance during postRelayedCall', async function () {
                        await misbehavingPaymaster.setWithdrawDuringPostRelayedCall(true);
                        await assertRevertWithRecipientBalanceChanged();
                    });
                    async function assertRevertWithRecipientBalanceChanged() {
                        const { logs } = await relayHubInstance.relayCall(relayRequestMisbehavingPaymaster, signature, '0x', gas, {
                            from: relayWorker,
                            gas,
                            gasPrice
                        });
                        test_helpers_1.expectEvent.inLogs(logs, 'TransactionRelayed', { status: RelayCallStatusCodes.RecipientBalanceChanged });
                    }
                });
            });
        });
    });
});
//# sourceMappingURL=RelayHub.test.js.map