"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/strict-boolean-expressions */
const child_process_1 = __importDefault(require("child_process"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const test_helpers_1 = require("@openzeppelin/test-helpers");
const HttpWrapper_1 = __importDefault(require("../src/relayclient/HttpWrapper"));
const HttpClient_1 = __importDefault(require("../src/relayclient/HttpClient"));
const GSNConfigurator_1 = require("../src/relayclient/GSNConfigurator");
const Environments_1 = require("../src/common/Environments");
require('source-map-support').install({ errorFormatterForce: true });
const RelayHub = artifacts.require('RelayHub');
const localhostOne = 'http://localhost:8090';
// start a background relay process.
// rhub - relay hub contract
// options:
//  stake, delay, pctRelayFee, url, relayOwner: parameters to pass to registerNewRelay, to stake and register it.
//
async function startRelay(relayHubAddress, stakeManager, options) {
    const args = [];
    const serverWorkDir = '/tmp/gsn/test/server';
    fs_1.default.rmdirSync(serverWorkDir, { recursive: true });
    args.push('--workdir', serverWorkDir);
    args.push('--devMode');
    args.push('--relayHubAddress', relayHubAddress);
    const configFile = path_1.default.resolve(__dirname, './server-config.json');
    args.push('--config', configFile);
    if (options.ethereumNodeUrl) {
        args.push('--ethereumNodeUrl', options.ethereumNodeUrl);
    }
    if (options.gasPricePercent) {
        args.push('--gasPricePercent', options.gasPricePercent);
    }
    if (options.pctRelayFee) {
        args.push('--pctRelayFee', options.pctRelayFee);
    }
    if (options.baseRelayFee) {
        args.push('--baseRelayFee', options.baseRelayFee);
    }
    const runServerPath = path_1.default.resolve(__dirname, '../src/relayserver/runServer.ts');
    const proc = child_process_1.default.spawn('./node_modules/.bin/ts-node', [runServerPath, ...args]);
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    let relaylog = function (_) { };
    if (options.relaylog) {
        relaylog = (msg) => msg.split('\n').forEach(line => console.log(`relay-${proc.pid.toString()}> ${line}`));
    }
    await new Promise((resolve, reject) => {
        let lastresponse;
        const listener = (data) => {
            const str = data.toString().replace(/\s+$/, '');
            lastresponse = str;
            relaylog(str);
            if (str.indexOf('Listening on port') >= 0) {
                // @ts-ignore
                proc.alreadystarted = 1;
                resolve(proc);
            }
        };
        proc.stdout.on('data', listener);
        proc.stderr.on('data', listener);
        const doaListener = (code) => {
            // @ts-ignore
            if (!proc.alreadystarted) {
                relaylog(`died before init code=${JSON.stringify(code)}`);
                reject(new Error(lastresponse));
            }
        };
        proc.on('exit', doaListener.bind(proc));
    });
    let res;
    const http = new HttpClient_1.default(new HttpWrapper_1.default(), GSNConfigurator_1.configureGSN({}));
    let count1 = 3;
    while (count1-- > 0) {
        try {
            res = await http.getPingResponse(localhostOne);
            if (res)
                break;
        }
        catch (e) {
            console.log('startRelay getaddr error', e);
        }
        console.log('sleep before cont.');
        await module.exports.sleep(1000);
    }
    assert.ok(res, 'can\'t ping server');
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    assert.ok(res.RelayServerAddress, `server returned unknown response ${res.toString()}`);
    const relayManagerAddress = res.RelayManagerAddress;
    console.log('Relay Server Address', relayManagerAddress);
    // @ts-ignore
    await web3.eth.sendTransaction({
        to: relayManagerAddress,
        from: options.relayOwner,
        value: test_helpers_1.ether('2')
    });
    await stakeManager.stakeForAddress(relayManagerAddress, options.delay || 2000, {
        from: options.relayOwner,
        value: options.stake || test_helpers_1.ether('1')
    });
    await sleep(500);
    await stakeManager.authorizeHubByOwner(relayManagerAddress, relayHubAddress, {
        from: options.relayOwner
    });
    // now ping server until it "sees" the stake and funding, and gets "ready"
    res = '';
    let count = 25;
    while (count-- > 0) {
        res = await http.getPingResponse(localhostOne);
        if (res === null || res === void 0 ? void 0 : res.Ready)
            break;
        await sleep(500);
    }
    assert.ok(res.Ready, 'Timed out waiting for relay to get staked and registered');
    // TODO: this is temporary hack to make helper test work!!!
    // @ts-ignore
    proc.relayManagerAddress = relayManagerAddress;
    return proc;
}
exports.startRelay = startRelay;
async function sleep(ms) {
    return await new Promise(resolve => setTimeout(resolve, ms));
}
exports.sleep = sleep;
function stopRelay(proc) {
    proc === null || proc === void 0 ? void 0 : proc.kill();
}
exports.stopRelay = stopRelay;
async function increaseTime(time) {
    return await new Promise((resolve, reject) => {
        // @ts-ignore
        web3.currentProvider.send({
            jsonrpc: '2.0',
            method: 'evm_increaseTime',
            params: [time],
            id: Date.now()
        }, (err) => {
            if (err)
                return reject(err);
            module.exports.evmMine()
                .then((r) => resolve(r))
                .catch((e) => reject(e));
        });
    });
}
exports.increaseTime = increaseTime;
async function evmMineMany(count) {
    for (let i = 0; i < count; i++) {
        await evmMine();
    }
}
exports.evmMineMany = evmMineMany;
async function evmMine() {
    return await new Promise((resolve, reject) => {
        // @ts-ignore
        web3.currentProvider.send({
            jsonrpc: '2.0',
            method: 'evm_mine',
            params: [],
            id: Date.now()
        }, (e, r) => {
            if (e) {
                reject(e);
            }
            else {
                resolve(r);
            }
        });
    });
}
exports.evmMine = evmMine;
async function snapshot() {
    return await new Promise((resolve, reject) => {
        // @ts-ignore
        web3.currentProvider.send({
            jsonrpc: '2.0',
            method: 'evm_snapshot',
            id: Date.now()
        }, (err, snapshotId) => {
            if (err) {
                return reject(err);
            }
            return resolve(snapshotId);
        });
    });
}
exports.snapshot = snapshot;
async function revert(id) {
    return await new Promise((resolve, reject) => {
        // @ts-ignore
        web3.currentProvider.send({
            jsonrpc: '2.0',
            method: 'evm_revert',
            params: [id],
            id: Date.now()
        }, (err, result) => {
            if (err) {
                return reject(err);
            }
            return resolve(result);
        });
    });
}
exports.revert = revert;
async function deployHub(stakeManager = test_helpers_1.constants.ZERO_ADDRESS, penalizer = test_helpers_1.constants.ZERO_ADDRESS) {
    return await RelayHub.new(stakeManager, penalizer, Environments_1.defaultEnvironment.relayHubConfiguration.maxWorkerCount, Environments_1.defaultEnvironment.relayHubConfiguration.gasReserve, Environments_1.defaultEnvironment.relayHubConfiguration.postOverhead, Environments_1.defaultEnvironment.relayHubConfiguration.gasOverhead, Environments_1.defaultEnvironment.relayHubConfiguration.maximumRecipientDeposit, Environments_1.defaultEnvironment.relayHubConfiguration.minimumUnstakeDelay, Environments_1.defaultEnvironment.relayHubConfiguration.minimumStake);
}
exports.deployHub = deployHub;
//# sourceMappingURL=TestUtils.js.map