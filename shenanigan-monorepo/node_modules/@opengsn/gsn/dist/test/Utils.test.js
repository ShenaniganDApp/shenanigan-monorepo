"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* global describe it web3 */
// @ts-ignore
const eth_sig_util_1 = require("eth-sig-util");
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const Utils_1 = require("../src/common/Utils");
const TypedRequestData_1 = __importStar(require("../src/common/EIP712/TypedRequestData"));
const test_helpers_1 = require("@openzeppelin/test-helpers");
const ethereumjs_util_1 = require("ethereumjs-util");
const assert = require('chai').use(chai_as_promised_1.default).assert;
const TestUtil = artifacts.require('TestUtil');
const Forwarder = artifacts.require('Forwarder');
const TestRecipient = artifacts.require('TestRecipient');
contract('Utils', function (accounts) {
    describe('#getEip712Signature()', function () {
        // ganache always reports chainId as '1'
        let chainId;
        let forwarder;
        let relayRequest;
        const senderAddress = accounts[0];
        let testUtil;
        let recipient;
        let forwarderInstance;
        before(async () => {
            testUtil = await TestUtil.new();
            chainId = (await testUtil.libGetChainID()).toNumber();
            forwarderInstance = await Forwarder.new();
            forwarder = forwarderInstance.address;
            recipient = await TestRecipient.new(forwarder);
            const senderNonce = '0';
            const target = recipient.address;
            const encodedFunction = '0xdeadbeef';
            const pctRelayFee = '15';
            const baseRelayFee = '1000';
            const gasPrice = '10000000';
            const gasLimit = '500000';
            // const forwarder = accounts[6]
            const paymaster = accounts[7];
            const relayWorker = accounts[9];
            const paymasterData = '0x';
            const clientId = '0';
            const res = await forwarderInstance.registerRequestType(TypedRequestData_1.GsnRequestType.typeName, TypedRequestData_1.GsnRequestType.typeSuffix);
            const typeName = res.logs[0].args.typeStr;
            relayRequest = {
                request: {
                    to: target,
                    data: encodedFunction,
                    from: senderAddress,
                    nonce: senderNonce,
                    value: '0',
                    gas: gasLimit
                },
                relayData: {
                    gasPrice,
                    pctRelayFee,
                    baseRelayFee,
                    relayWorker,
                    forwarder,
                    paymaster,
                    paymasterData,
                    clientId
                }
            };
            const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequest);
            assert.equal(typeName, eth_sig_util_1.TypedDataUtils.encodeType(dataToSign.primaryType, dataToSign.types));
        });
        it('#_getEncoded should extract data exactly as local encoded data', async () => {
            // @ts-ignore
            const { forwardRequest, typeHash, suffixData } = await testUtil.splitRequest(relayRequest);
            const getEncoded = await forwarderInstance._getEncoded(forwardRequest, typeHash, suffixData);
            const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequest);
            const localEncoded = ethereumjs_util_1.bufferToHex(eth_sig_util_1.TypedDataUtils.encodeData(dataToSign.primaryType, dataToSign.message, dataToSign.types));
            assert.equal(getEncoded, localEncoded);
        });
        it('library constants should match RelayHub eip712 constants', async function () {
            assert.equal(TypedRequestData_1.GsnRequestType.typeName, await testUtil.libRelayRequestName());
            assert.equal(TypedRequestData_1.GsnRequestType.typeSuffix, await testUtil.libRelayRequestSuffix());
            const res = await forwarderInstance.registerRequestType(TypedRequestData_1.GsnRequestType.typeName, TypedRequestData_1.GsnRequestType.typeSuffix);
            const { typeStr, typeHash } = res.logs[0].args;
            assert.equal(typeStr, await testUtil.libRelayRequestType());
            assert.equal(typeHash, await testUtil.libRelayRequestTypeHash());
        });
        it('should use same domainSeparator on-chain and off-chain', async () => {
            assert.equal(TypedRequestData_1.getDomainSeparatorHash(forwarder, chainId), await testUtil.libDomainSeparator(forwarder));
        });
        it('should generate a valid EIP-712 compatible signature', async function () {
            const dataToSign = new TypedRequestData_1.default(chainId, forwarder, relayRequest);
            const sig = await Utils_1.getEip712Signature(web3, dataToSign);
            const recoveredAccount = eth_sig_util_1.recoverTypedSignature_v4({
                data: dataToSign,
                sig
            });
            assert.strictEqual(senderAddress.toLowerCase(), recoveredAccount.toLowerCase());
            await testUtil.callForwarderVerify(relayRequest, sig);
        });
        describe('#callForwarderVerifyAndCall', () => {
            it('should return revert result', async function () {
                relayRequest.request.data = await recipient.contract.methods.testRevert().encodeABI();
                const sig = await Utils_1.getEip712Signature(web3, new TypedRequestData_1.default(chainId, forwarder, relayRequest));
                const ret = await testUtil.callForwarderVerifyAndCall(relayRequest, sig);
                const expectedReturnValue = '0x08c379a0' + Utils_1.removeHexPrefix(web3.eth.abi.encodeParameter('string', 'always fail'));
                test_helpers_1.expectEvent(ret, 'Called', {
                    success: false,
                    error: expectedReturnValue
                });
            });
            it('should call target', async function () {
                relayRequest.request.data = await recipient.contract.methods.emitMessage('hello').encodeABI();
                relayRequest.request.nonce = (await forwarderInstance.getNonce(relayRequest.request.from)).toString();
                const sig = await Utils_1.getEip712Signature(web3, new TypedRequestData_1.default(chainId, forwarder, relayRequest));
                const ret = await testUtil.callForwarderVerifyAndCall(relayRequest, sig);
                test_helpers_1.expectEvent(ret, 'Called', {
                    error: null
                });
                const logs = await recipient.contract.getPastEvents(null, { fromBlock: 1 });
                assert.equal(logs[0].event, 'SampleRecipientEmitted');
            });
        });
    });
});
//# sourceMappingURL=Utils.test.js.map