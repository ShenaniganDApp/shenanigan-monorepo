"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const sinon_1 = __importDefault(require("sinon"));
const RelayClient_1 = require("../../src/relayclient/RelayClient");
const RelaySelectionManager_1 = __importDefault(require("../../src/relayclient/RelaySelectionManager"));
const GSNConfigurator_1 = require("../../src/relayclient/GSNConfigurator");
const KnownRelaysManager_test_1 = require("./KnownRelaysManager.test");
const TestUtils_1 = require("../TestUtils");
const { expect, assert } = require('chai').use(chai_as_promised_1.default);
contract('RelaySelectionManager', function (accounts) {
    const sliceSize = 3;
    const verbose = false;
    const dependencyTree = GSNConfigurator_1.getDependencies(GSNConfigurator_1.configureGSN({}), web3.currentProvider);
    const stubGetRelaysSorted = sinon_1.default.stub(dependencyTree.knownRelaysManager, 'getRelaysSortedForTransaction');
    const errors = new Map();
    const config = GSNConfigurator_1.configureGSN({
        sliceSize,
        verbose
    });
    const eventInfo = {
        relayManager: '',
        relayUrl: '',
        baseRelayFee: '1',
        pctRelayFee: '1'
    };
    const pingResponse = {
        RelayServerAddress: '',
        RelayManagerAddress: '',
        RelayHubAddress: '',
        MinGasPrice: '1',
        Ready: true,
        Version: '1'
    };
    const winner = {
        pingResponse,
        relayInfo: eventInfo
    };
    const transactionDetails = {
        from: '',
        data: '',
        to: '',
        forwarder: '',
        paymaster: ''
    };
    let stubPingResponse;
    describe('#selectNextRelay()', function () {
        let relaySelectionManager;
        let stubRaceToSuccess;
        let stubGetNextSlice;
        before(function () {
            relaySelectionManager = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, RelayClient_1.GasPricePingFilter, config);
            stubRaceToSuccess = sinon_1.default.stub(relaySelectionManager, '_raceToSuccess');
            stubGetNextSlice = sinon_1.default.stub(relaySelectionManager, '_getNextSlice');
            // unless this is stubbed, promises will not be handled and exception will be thrown somewhere
            // @ts-ignore
            sinon_1.default.stub(relaySelectionManager, '_getRelayAddressPing').returns(Promise.resolve(winner));
        });
        afterEach(function () {
            stubGetNextSlice.reset();
            stubRaceToSuccess.reset();
        });
        it('should return the first relay to ping', async function () {
            stubGetNextSlice.returns([eventInfo]);
            stubRaceToSuccess
                .onFirstCall()
                .returns(Promise.resolve({ errors }))
                .onSecondCall()
                .returns(Promise.resolve({
                winner,
                errors
            }));
            const nextRelay = await relaySelectionManager.selectNextRelay(transactionDetails);
            assert.equal(nextRelay, winner);
        });
        describe('with preferred relay URL', function () {
            const preferredRelayUrl = 'preferredRelayUrl';
            const relayManager = accounts[1];
            let relaySelectionManager;
            let stubRaceToSuccess;
            let stubGetNextSlice;
            let relayHub;
            let dependencyTree;
            before(async function () {
                const StakeManager = artifacts.require('StakeManager');
                const stakeManager = await StakeManager.new();
                relayHub = await TestUtils_1.deployHub(stakeManager.address);
                await KnownRelaysManager_test_1.stake(stakeManager, relayHub, relayManager, accounts[0]);
                await KnownRelaysManager_test_1.register(relayHub, relayManager, accounts[2], preferredRelayUrl, '666', '777');
                const config = GSNConfigurator_1.configureGSN({
                    relayHubAddress: relayHub.address,
                    stakeManagerAddress: stakeManager.address
                });
                dependencyTree = GSNConfigurator_1.getDependencies(config, web3.currentProvider);
                relaySelectionManager =
                    new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, RelayClient_1.GasPricePingFilter, config);
                stubRaceToSuccess = sinon_1.default.stub(relaySelectionManager, '_raceToSuccess');
                stubGetNextSlice = sinon_1.default.stub(relaySelectionManager, '_getNextSlice');
            });
            it('should fill in the details if the relay was known only by URL', async function () {
                const urlInfo = { relayUrl: preferredRelayUrl };
                const pingResponse = {
                    RelayServerAddress: relayManager,
                    RelayManagerAddress: relayManager,
                    RelayHubAddress: relayManager,
                    MinGasPrice: '1',
                    Ready: true,
                    Version: ''
                };
                const winner = {
                    pingResponse,
                    relayInfo: urlInfo
                };
                stubGetNextSlice.returns([urlInfo]);
                stubRaceToSuccess.returns(Promise.resolve({
                    winner,
                    errors
                }));
                stubGetRelaysSorted.returns(Promise.resolve([[urlInfo]]));
                const nextRelay = await relaySelectionManager.selectNextRelay(transactionDetails);
                assert.equal(nextRelay.relayInfo.relayUrl, preferredRelayUrl);
                assert.equal(nextRelay.relayInfo.relayManager, relayManager);
                assert.equal(nextRelay.relayInfo.baseRelayFee, '666');
                assert.equal(nextRelay.relayInfo.pctRelayFee, '777');
            });
        });
        it('should return null if no relay could ping', async function () {
            stubGetNextSlice
                .onFirstCall()
                .returns([eventInfo])
                .onSecondCall()
                .returns([]);
            stubRaceToSuccess
                .returns(Promise.resolve({ errors }));
            const nextRelay = await relaySelectionManager.selectNextRelay(transactionDetails);
            assert.isUndefined(nextRelay);
        });
    });
    describe('#_getNextSlice()', function () {
        it('should return \'relaySliceSize\' relays if available on the highest priority level', async function () {
            stubGetRelaysSorted.returns(Promise.resolve([[winner.relayInfo, winner.relayInfo, winner.relayInfo, winner.relayInfo, winner.relayInfo]]));
            for (let i = 1; i < 5; i++) {
                const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, RelayClient_1.GasPricePingFilter, GSNConfigurator_1.configureGSN({
                    sliceSize: i,
                    verbose
                }));
                const returned = await rsm._getNextSlice(transactionDetails);
                assert.equal(returned.length, i);
            }
        });
        it('should return all remaining relays if less then \'relaySliceSize\' remains on current priority level', async function () {
            const relaysLeft = [[winner.relayInfo, winner.relayInfo]];
            stubGetRelaysSorted.returns(Promise.resolve(relaysLeft));
            const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, RelayClient_1.GasPricePingFilter, GSNConfigurator_1.configureGSN({
                sliceSize: 7,
                verbose
            }));
            const returned = await rsm._getNextSlice(transactionDetails);
            assert.deepEqual(returned, relaysLeft[0]);
        });
        it('should start returning relays from lower priority level if higher level is empty', async function () {
            // Create stub array of distinct relay URLs (URL is used as mapping key)
            const relayInfoGenerator = (e, i, a) => {
                return Object.assign(Object.assign({}, e), { relayUrl: `relay ${i} of ${a.length}` });
            };
            const relaysLeft = [Array(2).fill(winner).map(relayInfoGenerator), Array(3).fill(winner).map(relayInfoGenerator)];
            stubGetRelaysSorted.returns(Promise.resolve(relaysLeft));
            const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, RelayClient_1.GasPricePingFilter, GSNConfigurator_1.configureGSN({
                sliceSize: 7,
                verbose
            }));
            // Initial request only returns the top preference relays
            const returned1 = await rsm._getNextSlice(transactionDetails);
            assert.equal(returned1.length, 2);
            // Pretend all relays failed to ping
            let errors = new Map(returned1.map(info => [info.relayUrl, new Error('fake error')]));
            rsm._handleRaceResults({ errors });
            const returned2 = await rsm._getNextSlice(transactionDetails);
            assert.equal(returned2.length, 3);
            errors = new Map(returned2.map(info => [info.relayUrl, new Error('fake error')]));
            rsm._handleRaceResults({ errors });
            const returned3 = await rsm._getNextSlice(transactionDetails);
            assert.equal(returned3.length, 0);
        });
    });
    describe('#_getRelayAddressPing()', function () {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const emptyFilter = () => { };
        before(function () {
            stubPingResponse = sinon_1.default.stub(dependencyTree.httpClient, 'getPingResponse');
        });
        it('should throw if the relay is not ready', async function () {
            stubPingResponse.returns(Promise.resolve(Object.assign({}, pingResponse, { Ready: false })));
            const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, emptyFilter, config);
            const promise = rsm._getRelayAddressPing(eventInfo);
            await expect(promise).to.be.eventually.rejectedWith('Relay not ready');
        });
        // TODO: change the way filtering is implemented
        it('should call filter and not catch exceptions in it', async function () {
            const message = 'Filter Error Message';
            const filter = () => { throw new Error(message); };
            stubPingResponse.returns(Promise.resolve(pingResponse));
            const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, filter, config);
            const promise = rsm._getRelayAddressPing(eventInfo);
            await expect(promise).to.be.eventually.rejectedWith(message);
        });
        it('should return the relay info if it pinged as ready and passed filter successfully', async function () {
            stubPingResponse.returns(Promise.resolve(pingResponse));
            const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, emptyFilter, config);
            const relayInfo = await rsm._getRelayAddressPing(eventInfo);
            assert.deepEqual(relayInfo, winner);
        });
    });
    describe('#_raceToSuccess()', function () {
        // Note that promises must be created and passed to the 'raceToSuccess' in the same, synchronous block.
        // Otherwise, rejections will not be handled and mocha will crash.
        it('only first to resolve and all that rejected by that time', async function () {
            var _a, _b;
            const slowRelay = {
                pingResponse,
                relayInfo: Object.assign({}, eventInfo, { relayUrl: 'slowRelay' })
            };
            const fastRelay = {
                pingResponse,
                relayInfo: Object.assign({}, eventInfo, { relayUrl: 'fastRelay' })
            };
            const fastFailRelay = {
                pingResponse,
                relayInfo: Object.assign({}, eventInfo, { relayUrl: 'fastFailRelay' })
            };
            const slowFailRelay = {
                pingResponse,
                relayInfo: Object.assign({}, eventInfo, { relayUrl: 'slowFailRelay' })
            };
            const slowPromise = new Promise((resolve) => {
                setTimeout(() => { resolve(pingResponse); }, 1500);
            });
            const fastPromise = new Promise((resolve) => {
                setTimeout(() => { resolve(pingResponse); }, 300);
            });
            const fastFailPromise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(new Error(fastFailedMessage));
                }, 180);
            });
            const slowFailPromise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(new Error(slowFailedMessage));
                }, 1800);
            });
            const fastFailedMessage = 'Fast Failed Promise';
            const slowFailedMessage = 'Slow Failed Promise';
            const relays = [slowRelay.relayInfo, fastRelay.relayInfo, slowFailRelay.relayInfo, fastFailRelay.relayInfo];
            stubPingResponse.callsFake(async (relayUrl) => {
                switch (relayUrl) {
                    case slowRelay.relayInfo.relayUrl:
                        return await slowPromise;
                    case fastRelay.relayInfo.relayUrl:
                        return await fastPromise;
                    case slowFailRelay.relayInfo.relayUrl:
                        return await slowFailPromise;
                    case fastFailRelay.relayInfo.relayUrl:
                        return await fastFailPromise;
                }
                throw new Error('Non test relay pinged');
            });
            const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, RelayClient_1.GasPricePingFilter, config);
            const raceResults = await rsm._raceToSuccess(relays);
            assert.equal((_a = raceResults.winner) === null || _a === void 0 ? void 0 : _a.relayInfo.relayUrl, 'fastRelay');
            assert.equal(raceResults.errors.size, 1);
            assert.equal((_b = raceResults.errors.get('fastFailRelay')) === null || _b === void 0 ? void 0 : _b.message, fastFailedMessage);
        });
    });
    describe('#_handleRaceResults()', function () {
        const winnerRelayUrl = 'winnerRelayUrl';
        const failureRelayUrl = 'failureRelayUrl';
        const otherRelayUrl = 'otherRelayUrl';
        const winner = {
            pingResponse,
            relayInfo: Object.assign({}, eventInfo, { relayUrl: winnerRelayUrl })
        };
        const message = 'some failure message';
        const failureRelayEventInfo = Object.assign({}, eventInfo, { relayUrl: failureRelayUrl });
        const otherRelayEventInfo = Object.assign({}, eventInfo, { relayUrl: otherRelayUrl });
        it('should remove all relays featured in race results', async function () {
            sinon_1.default.stub(dependencyTree.knownRelaysManager, 'refresh');
            stubGetRelaysSorted.returns(Promise.resolve([[winner.relayInfo, failureRelayEventInfo, otherRelayEventInfo]]));
            const rsm = new RelaySelectionManager_1.default(transactionDetails, dependencyTree.knownRelaysManager, dependencyTree.httpClient, RelayClient_1.GasPricePingFilter, config);
            // initialize 'remainingRelays' field by calling '_getNextSlice'
            await rsm._getNextSlice(transactionDetails);
            const errors = new Map();
            errors.set(failureRelayUrl, new Error(message));
            const raceResults = {
                winner,
                errors
            };
            // @ts-ignore
            let remainingRelays = rsm.remainingRelays;
            assert.equal(remainingRelays === null || remainingRelays === void 0 ? void 0 : remainingRelays.length, 1);
            assert.equal(remainingRelays[0].length, 3);
            assert.equal(remainingRelays[0][0].relayUrl, winnerRelayUrl);
            assert.equal(remainingRelays[0][1].relayUrl, failureRelayUrl);
            assert.equal(remainingRelays[0][2].relayUrl, otherRelayUrl);
            rsm._handleRaceResults(raceResults);
            // @ts-ignore
            remainingRelays = rsm.remainingRelays;
            assert.equal(remainingRelays === null || remainingRelays === void 0 ? void 0 : remainingRelays.length, 1);
            assert.equal(remainingRelays[0][0].relayUrl, otherRelayUrl);
        });
    });
});
//# sourceMappingURL=RelaySelectionManager.test.js.map