"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const transaction_1 = __importDefault(require("ethereumjs-tx/dist/transaction"));
const web3_1 = __importDefault(require("web3"));
const chai_1 = __importDefault(require("chai"));
const sinon_1 = __importDefault(require("sinon"));
const sinon_chai_1 = __importDefault(require("sinon-chai"));
const RelayClient_1 = require("../../src/relayclient/RelayClient");
const GSNConfigurator_1 = require("../../src/relayclient/GSNConfigurator");
const ErrorReplacerJSON_1 = __importDefault(require("../../src/common/ErrorReplacerJSON"));
const BadHttpClient_1 = __importDefault(require("../dummies/BadHttpClient"));
const BadContractInteractor_1 = __importDefault(require("../dummies/BadContractInteractor"));
const BadRelayedTransactionValidator_1 = __importDefault(require("../dummies/BadRelayedTransactionValidator"));
const TestUtils_1 = require("../TestUtils");
const TypedRequestData_1 = require("../../src/common/EIP712/TypedRequestData");
const StakeManager = artifacts.require('StakeManager');
const TestRecipient = artifacts.require('TestRecipient');
const TestPaymasterEverythingAccepted = artifacts.require('TestPaymasterEverythingAccepted');
const Forwarder = artifacts.require('Forwarder');
const expect = chai_1.default.expect;
chai_1.default.use(sinon_chai_1.default);
const localhostOne = 'http://localhost:8090';
const underlyingProvider = web3.currentProvider;
contract('RelayClient', function (accounts) {
    let web3;
    let relayHub;
    let stakeManager;
    let testRecipient;
    let paymaster;
    let gasLess;
    let relayProcess;
    let forwarderAddress;
    let relayClient;
    let gsnConfig;
    let options;
    let to;
    let from;
    let data;
    before(async function () {
        web3 = new web3_1.default(underlyingProvider);
        stakeManager = await StakeManager.new();
        relayHub = await TestUtils_1.deployHub(stakeManager.address);
        const forwarderInstance = await Forwarder.new();
        forwarderAddress = forwarderInstance.address;
        testRecipient = await TestRecipient.new(forwarderAddress);
        // register hub's RelayRequest with forwarder, if not already done.
        await forwarderInstance.registerRequestType(TypedRequestData_1.GsnRequestType.typeName, TypedRequestData_1.GsnRequestType.typeSuffix);
        paymaster = await TestPaymasterEverythingAccepted.new();
        await paymaster.setRelayHub(relayHub.address);
        await paymaster.deposit({ value: web3.utils.toWei('1', 'ether') });
        relayProcess = await TestUtils_1.startRelay(relayHub.address, stakeManager, {
            stake: 1e18,
            url: 'asd',
            relayOwner: accounts[1],
            ethereumNodeUrl: underlyingProvider.host
        });
        gsnConfig = {
            relayHubAddress: relayHub.address,
            stakeManagerAddress: stakeManager.address
        };
        relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig);
        gasLess = await web3.eth.personal.newAccount('password');
        from = gasLess;
        to = testRecipient.address;
        data = testRecipient.contract.methods.emitMessage('hello world').encodeABI();
        options = {
            from,
            to,
            data,
            forwarder: forwarderAddress,
            paymaster: paymaster.address,
            paymasterData: '0x',
            clientId: '1'
        };
    });
    after(async function () {
        await TestUtils_1.stopRelay(relayProcess);
    });
    describe('#relayTransaction()', function () {
        it('should send transaction to a relay and receive a signed transaction in response', async function () {
            var _a;
            const relayingResult = await relayClient.relayTransaction(options);
            const validTransaction = relayingResult.transaction;
            if (validTransaction == null) {
                assert.fail(`validTransaction is null: ${JSON.stringify(relayingResult, ErrorReplacerJSON_1.default)}`);
                return;
            }
            const validTransactionHash = validTransaction.hash(true).toString('hex');
            const txHash = `0x${validTransactionHash}`;
            const res = await web3.eth.getTransactionReceipt(txHash);
            // validate we've got the "SampleRecipientEmitted" event
            // TODO: use OZ test helpers
            const topic = (_a = web3.utils.sha3('SampleRecipientEmitted(string,address,address,address,uint256,uint256)')) !== null && _a !== void 0 ? _a : '';
            assert(res.logs.find(log => log.topics.includes(topic)));
            const destination = validTransaction.to.toString('hex');
            assert.equal(`0x${destination}`, relayHub.address.toString().toLowerCase());
        });
        it('should use forceGasPrice if provided', async function () {
            const forceGasPrice = '0x777777777';
            const optionsForceGas = Object.assign({}, options, { forceGasPrice });
            const { transaction, pingErrors, relayingErrors } = await relayClient.relayTransaction(optionsForceGas);
            assert.equal(pingErrors.size, 0);
            assert.equal(relayingErrors.size, 0);
            assert.equal(parseInt(transaction.gasPrice.toString('hex'), 16), parseInt(forceGasPrice));
        });
        it('should return errors encountered in ping', async function () {
            const badHttpClient = new BadHttpClient_1.default(GSNConfigurator_1.configureGSN(gsnConfig), true, false, false);
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, { httpClient: badHttpClient });
            const { transaction, relayingErrors, pingErrors } = await relayClient.relayTransaction(options);
            assert.isUndefined(transaction);
            assert.equal(relayingErrors.size, 0);
            assert.equal(pingErrors.size, 1);
            assert.equal(pingErrors.get(localhostOne).message, BadHttpClient_1.default.message);
        });
        it('should return errors encountered in relaying', async function () {
            const badHttpClient = new BadHttpClient_1.default(GSNConfigurator_1.configureGSN(gsnConfig), false, true, false);
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, { httpClient: badHttpClient });
            const { transaction, relayingErrors, pingErrors } = await relayClient.relayTransaction(options);
            assert.isUndefined(transaction);
            assert.equal(pingErrors.size, 0);
            assert.equal(relayingErrors.size, 1);
            assert.equal(relayingErrors.get(localhostOne).message, BadHttpClient_1.default.message);
        });
    });
    describe('#_calculateDefaultGasPrice()', function () {
        it('should use minimum gas price if calculated is to low', async function () {
            const minGasPrice = 1e18;
            const gsnConfig = {
                relayHubAddress: relayHub.address,
                minGasPrice
            };
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig);
            const calculatedGasPrice = await relayClient._calculateGasPrice();
            assert.equal(calculatedGasPrice, `0x${minGasPrice.toString(16)}`);
        });
    });
    describe('#_attemptRelay()', function () {
        const relayUrl = localhostOne;
        const RelayServerAddress = accounts[1];
        const relayManager = accounts[2];
        const relayOwner = accounts[3];
        let pingResponse;
        let relayInfo;
        let optionsWithGas;
        before(async function () {
            await stakeManager.stakeForAddress(relayManager, 7 * 24 * 3600, {
                from: relayOwner,
                value: (2e18).toString()
            });
            await stakeManager.authorizeHubByOwner(relayManager, relayHub.address, { from: relayOwner });
            await relayHub.addRelayWorkers([RelayServerAddress], { from: relayManager });
            await relayHub.registerRelayServer(2e16.toString(), '10', 'url', { from: relayManager });
            await relayHub.depositFor(paymaster.address, { value: (2e18).toString() });
            pingResponse = {
                RelayServerAddress,
                RelayManagerAddress: relayManager,
                RelayHubAddress: relayManager,
                MinGasPrice: '',
                Ready: true,
                Version: ''
            };
            relayInfo = {
                relayInfo: {
                    relayManager,
                    relayUrl,
                    baseRelayFee: '',
                    pctRelayFee: ''
                },
                pingResponse
            };
            optionsWithGas = Object.assign({}, options, {
                gas: '0xf4240',
                gasPrice: '0x51f4d5c00'
            });
        });
        it('should return error if view call to \'relayCall()\' fails', async function () {
            const badContractInteractor = new BadContractInteractor_1.default(web3.currentProvider, GSNConfigurator_1.configureGSN(gsnConfig), true);
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, { contractInteractor: badContractInteractor });
            await relayClient._init();
            const { transaction, error } = await relayClient._attemptRelay(relayInfo, optionsWithGas);
            assert.isUndefined(transaction);
            assert.equal(error.message, `local view call to 'relayCall()' reverted: ${BadContractInteractor_1.default.message}`);
        });
        it('should report relays that timeout to the Known Relays Manager', async function () {
            var _a;
            const badHttpClient = new BadHttpClient_1.default(GSNConfigurator_1.configureGSN(gsnConfig), false, false, true);
            const dependencyTree = GSNConfigurator_1.getDependencies(GSNConfigurator_1.configureGSN(gsnConfig), underlyingProvider, { httpClient: badHttpClient });
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, dependencyTree);
            await relayClient._init();
            // @ts-ignore (sinon allows spying on all methods of the object, but TypeScript does not seem to know that)
            sinon_1.default.spy(dependencyTree.knownRelaysManager);
            const attempt = await relayClient._attemptRelay(relayInfo, optionsWithGas);
            assert.equal((_a = attempt.error) === null || _a === void 0 ? void 0 : _a.message, 'some error describing how timeout occurred somewhere');
            expect(dependencyTree.knownRelaysManager.saveRelayFailure).to.have.been.calledWith(sinon_1.default.match.any, relayManager, relayUrl);
        });
        it('should not report relays if error is not timeout', async function () {
            const badHttpClient = new BadHttpClient_1.default(GSNConfigurator_1.configureGSN(gsnConfig), false, true, false);
            const dependencyTree = GSNConfigurator_1.getDependencies(GSNConfigurator_1.configureGSN(gsnConfig), underlyingProvider, { httpClient: badHttpClient });
            dependencyTree.httpClient = badHttpClient;
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, dependencyTree);
            // @ts-ignore (sinon allows spying on all methods of the object, but TypeScript does not seem to know that)
            sinon_1.default.spy(dependencyTree.knownRelaysManager);
            await relayClient._attemptRelay(relayInfo, optionsWithGas);
            expect(dependencyTree.knownRelaysManager.saveRelayFailure).to.have.not.been.called;
        });
        it('should return error if transaction returned by a relay does not pass validation', async function () {
            const badHttpClient = new BadHttpClient_1.default(GSNConfigurator_1.configureGSN(gsnConfig), false, false, false, pingResponse, '0x123');
            let dependencyTree = GSNConfigurator_1.getDependencies(GSNConfigurator_1.configureGSN(gsnConfig), underlyingProvider);
            const badTransactionValidator = new BadRelayedTransactionValidator_1.default(true, dependencyTree.contractInteractor, GSNConfigurator_1.configureGSN(gsnConfig));
            dependencyTree = GSNConfigurator_1.getDependencies(GSNConfigurator_1.configureGSN(gsnConfig), underlyingProvider, {
                httpClient: badHttpClient,
                transactionValidator: badTransactionValidator
            });
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, dependencyTree);
            await relayClient._init();
            // @ts-ignore (sinon allows spying on all methods of the object, but TypeScript does not seem to know that)
            sinon_1.default.spy(dependencyTree.knownRelaysManager);
            const { transaction, error } = await relayClient._attemptRelay(relayInfo, optionsWithGas);
            assert.isUndefined(transaction);
            assert.equal(error.message, 'Returned transaction did not pass validation');
            expect(dependencyTree.knownRelaysManager.saveRelayFailure).to.have.been.calledWith(sinon_1.default.match.any, relayManager, relayUrl);
        });
        describe('#_prepareRelayHttpRequest()', function () {
            const asyncApprovalData = async function (_) {
                return await Promise.resolve('0x1234567890');
            };
            const asyncPaymasterData = async function (_) {
                return await Promise.resolve('0xabcd');
            };
            it('should use provided approval function', async function () {
                const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, {
                    asyncApprovalData,
                    asyncPaymasterData
                });
                const { httpRequest } = await relayClient._prepareRelayHttpRequest(relayInfo, optionsWithGas);
                assert.equal(httpRequest.approvalData, '0x1234567890');
                assert.equal(httpRequest.paymasterData, '0xabcd');
            });
        });
    });
    describe('#_broadcastRawTx()', function () {
        // TODO: TBD: there has to be other behavior then that. Maybe query the transaction with the nonce somehow?
        it('should return \'wrongNonce\' if broadcast fails with nonce error', async function () {
            const badContractInteractor = new BadContractInteractor_1.default(underlyingProvider, GSNConfigurator_1.configureGSN(gsnConfig), true);
            const transaction = new transaction_1.default('0x');
            const relayClient = new RelayClient_1.RelayClient(underlyingProvider, gsnConfig, { contractInteractor: badContractInteractor });
            const { receipt, wrongNonce, broadcastError } = await relayClient._broadcastRawTx(transaction);
            assert.isUndefined(receipt);
            assert.isTrue(wrongNonce);
            assert.equal(broadcastError === null || broadcastError === void 0 ? void 0 : broadcastError.message, BadContractInteractor_1.default.wrongNonceMessage);
        });
    });
});
//# sourceMappingURL=RelayClient.test.js.map