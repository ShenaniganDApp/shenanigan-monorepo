"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@openzeppelin/test-helpers");
const KnownRelaysManager_1 = __importStar(require("../../src/relayclient/KnownRelaysManager"));
const ContractInteractor_1 = __importDefault(require("../../src/relayclient/ContractInteractor"));
const GSNConfigurator_1 = require("../../src/relayclient/GSNConfigurator");
const TestUtils_1 = require("../TestUtils");
const RelayProvider_test_1 = require("./RelayProvider.test");
const sinon_1 = __importDefault(require("sinon"));
const TypedRequestData_1 = require("../../src/common/EIP712/TypedRequestData");
const StakeManager = artifacts.require('StakeManager');
const TestRecipient = artifacts.require('TestRecipient');
const TestPaymasterConfigurableMisbehavior = artifacts.require('TestPaymasterConfigurableMisbehavior');
const Forwarder = artifacts.require('Forwarder');
async function stake(stakeManager, relayHub, manager, owner) {
    await stakeManager.stakeForAddress(manager, 1000, {
        value: test_helpers_1.ether('1'),
        from: owner
    });
    await stakeManager.authorizeHubByOwner(manager, relayHub.address, { from: owner });
}
exports.stake = stake;
async function register(relayHub, manager, worker, url, baseRelayFee, pctRelayFee) {
    await relayHub.addRelayWorkers([worker], { from: manager });
    await relayHub.registerRelayServer(baseRelayFee !== null && baseRelayFee !== void 0 ? baseRelayFee : '0', pctRelayFee !== null && pctRelayFee !== void 0 ? pctRelayFee : '0', url, { from: manager });
}
exports.register = register;
contract('KnownRelaysManager', function ([activeRelayWorkersAdded, activeRelayServerRegistered, activePaymasterRejected, activeTransactionRelayed, notActiveRelay, workerPaymasterRejected, workerTransactionRelayed, owner, other]) {
    const relayLookupWindowBlocks = 100;
    describe('#_fetchRecentlyActiveRelayManagers()', function () {
        let config;
        let contractInteractor;
        let stakeManager;
        let relayHub;
        let testRecipient;
        let paymaster;
        let workerRelayWorkersAdded;
        let workerRelayServerRegistered;
        let workerNotActive;
        const gas = 4e6;
        before(async function () {
            workerRelayWorkersAdded = await web3.eth.personal.newAccount('password');
            workerRelayServerRegistered = await web3.eth.personal.newAccount('password');
            workerNotActive = await web3.eth.personal.newAccount('password');
            stakeManager = await StakeManager.new();
            relayHub = await TestUtils_1.deployHub(stakeManager.address);
            config = GSNConfigurator_1.configureGSN({
                relayHubAddress: relayHub.address,
                relayLookupWindowBlocks
            });
            contractInteractor = new ContractInteractor_1.default(web3.currentProvider, config);
            const forwarderInstance = await Forwarder.new();
            const forwarderAddress = forwarderInstance.address;
            testRecipient = await TestRecipient.new(forwarderAddress);
            await forwarderInstance.registerRequestType(TypedRequestData_1.GsnRequestType.typeName, TypedRequestData_1.GsnRequestType.typeSuffix);
            paymaster = await TestPaymasterConfigurableMisbehavior.new();
            await paymaster.setRelayHub(relayHub.address);
            await paymaster.deposit({ value: test_helpers_1.ether('1') });
            await stake(stakeManager, relayHub, activeRelayWorkersAdded, owner);
            await stake(stakeManager, relayHub, activeRelayServerRegistered, owner);
            await stake(stakeManager, relayHub, activePaymasterRejected, owner);
            await stake(stakeManager, relayHub, activeTransactionRelayed, owner);
            await stake(stakeManager, relayHub, notActiveRelay, owner);
            const txPaymasterRejected = await RelayProvider_test_1.prepareTransaction(testRecipient, other, workerPaymasterRejected, paymaster.address, web3);
            const txTransactionRelayed = await RelayProvider_test_1.prepareTransaction(testRecipient, other, workerTransactionRelayed, paymaster.address, web3);
            /** events that are not supposed to be visible to the manager */
            await relayHub.addRelayWorkers([workerRelayServerRegistered], {
                from: activeRelayServerRegistered
            });
            await relayHub.addRelayWorkers([workerNotActive], {
                from: notActiveRelay
            });
            await relayHub.addRelayWorkers([workerTransactionRelayed], {
                from: activeTransactionRelayed
            });
            await relayHub.addRelayWorkers([workerPaymasterRejected], {
                from: activePaymasterRejected
            });
            await relayHub.registerRelayServer('0', '0', '', { from: activeTransactionRelayed });
            await relayHub.registerRelayServer('0', '0', '', { from: activePaymasterRejected });
            await TestUtils_1.evmMineMany(relayLookupWindowBlocks);
            /** events that are supposed to be visible to the manager */
            await relayHub.registerRelayServer('0', '0', '', { from: activeRelayServerRegistered });
            await relayHub.addRelayWorkers([workerRelayWorkersAdded], {
                from: activeRelayWorkersAdded
            });
            await relayHub.relayCall(txTransactionRelayed.relayRequest, txTransactionRelayed.signature, '0x', gas, {
                from: workerTransactionRelayed,
                gas,
                gasPrice: txTransactionRelayed.relayRequest.relayData.gasPrice
            });
            await paymaster.setReturnInvalidErrorCode(true);
            await relayHub.relayCall(txPaymasterRejected.relayRequest, txPaymasterRejected.signature, '0x', gas, {
                from: workerPaymasterRejected,
                gas,
                gasPrice: txPaymasterRejected.relayRequest.relayData.gasPrice
            });
        });
        it('should contain all relay managers only if their workers were active in the last \'relayLookupWindowBlocks\' blocks', async function () {
            const knownRelaysManager = new KnownRelaysManager_1.default(contractInteractor, config);
            const res = await knownRelaysManager._fetchRecentlyActiveRelayManagers();
            const actual = Array.from(res.values());
            assert.equal(actual.length, 4);
            assert.equal(actual[0], activeRelayServerRegistered);
            assert.equal(actual[1], activeRelayWorkersAdded);
            assert.equal(actual[2], activeTransactionRelayed);
            assert.equal(actual[3], activePaymasterRejected);
        });
    });
});
contract('KnownRelaysManager 2', function (accounts) {
    const contractInteractor = new ContractInteractor_1.default(web3.currentProvider, GSNConfigurator_1.configureGSN({}));
    const transactionDetails = {
        gas: '0x10000',
        gasPrice: '0x300000',
        from: '',
        data: '',
        to: '',
        forwarder: '',
        paymaster: ''
    };
    describe('#refresh()', function () {
        let relayProcess;
        let knownRelaysManager;
        let contractInteractor;
        let stakeManager;
        let relayHub;
        let config;
        before(async function () {
            stakeManager = await StakeManager.new();
            relayHub = await TestUtils_1.deployHub(stakeManager.address);
            config = GSNConfigurator_1.configureGSN({
                preferredRelays: ['http://localhost:8090'],
                relayHubAddress: relayHub.address,
                stakeManagerAddress: stakeManager.address
            });
            relayProcess = await TestUtils_1.startRelay(relayHub.address, stakeManager, {
                stake: 1e18,
                url: 'asd',
                relayOwner: accounts[1],
                ethereumNodeUrl: web3.currentProvider.host
            });
            contractInteractor = new ContractInteractor_1.default(web3.currentProvider, config);
            knownRelaysManager = new KnownRelaysManager_1.default(contractInteractor, config);
            await stake(stakeManager, relayHub, accounts[1], accounts[0]);
            await stake(stakeManager, relayHub, accounts[2], accounts[0]);
            await stake(stakeManager, relayHub, accounts[3], accounts[0]);
            await stake(stakeManager, relayHub, accounts[4], accounts[0]);
            await register(relayHub, accounts[1], accounts[6], 'stakeAndAuthorization1');
            await register(relayHub, accounts[2], accounts[7], 'stakeAndAuthorization2');
            await register(relayHub, accounts[3], accounts[8], 'stakeUnlocked');
            await register(relayHub, accounts[4], accounts[9], 'hubUnauthorized');
            await stakeManager.unlockStake(accounts[3]);
            await stakeManager.unauthorizeHubByOwner(accounts[4], relayHub.address);
        });
        after(async function () {
            await TestUtils_1.stopRelay(relayProcess);
        });
        it('should consider all relay managers with stake and authorization as active', async function () {
            await knownRelaysManager.refresh();
            const preferredRelays = knownRelaysManager.knownRelays[0];
            const activeRelays = knownRelaysManager.knownRelays[1];
            assert.equal(preferredRelays.length, 1);
            assert.equal(preferredRelays[0].relayUrl, 'http://localhost:8090');
            assert.equal(activeRelays.length, 3);
            assert.equal(activeRelays[0].relayUrl, 'http://localhost:8090');
            assert.equal(activeRelays[1].relayUrl, 'stakeAndAuthorization1');
            assert.equal(activeRelays[2].relayUrl, 'stakeAndAuthorization2');
        });
        it('should use \'relayFilter\' to remove unsuitable relays', async function () {
            const relayFilter = (registeredEventInfo) => {
                return registeredEventInfo.relayUrl.includes('2');
            };
            const knownRelaysManagerWithFilter = new KnownRelaysManager_1.default(contractInteractor, config, relayFilter);
            await knownRelaysManagerWithFilter.refresh();
            const relays = knownRelaysManagerWithFilter.knownRelays[1];
            assert.equal(relays.length, 1);
            assert.equal(relays[0].relayUrl, 'stakeAndAuthorization2');
        });
    });
    describe('#getRelaysSortedForTransaction()', function () {
        const relayInfoLowFee = {
            relayManager: accounts[0],
            relayUrl: 'lowFee',
            baseRelayFee: '1000000',
            pctRelayFee: '10'
        };
        const relayInfoHighFee = {
            relayManager: accounts[0],
            relayUrl: 'highFee',
            baseRelayFee: '100000000',
            pctRelayFee: '50'
        };
        const knownRelaysManager = new KnownRelaysManager_1.default(contractInteractor, GSNConfigurator_1.configureGSN({}));
        describe('#_refreshFailures()', function () {
            let lastErrorTime;
            before(function () {
                knownRelaysManager.saveRelayFailure(100, 'rm1', 'url1');
                knownRelaysManager.saveRelayFailure(500, 'rm2', 'url2');
                lastErrorTime = Date.now();
                knownRelaysManager.saveRelayFailure(lastErrorTime, 'rm3', 'url3');
            });
            it('should remove the failures that occurred more than \'relayTimeoutGrace\' seconds ago', function () {
                // @ts-ignore
                knownRelaysManager.relayFailures.forEach(failures => {
                    assert.equal(failures.length, 1);
                });
                knownRelaysManager._refreshFailures();
                // @ts-ignore
                assert.equal(knownRelaysManager.relayFailures.get('url1').length, 0);
                // @ts-ignore
                assert.equal(knownRelaysManager.relayFailures.get('url2').length, 0);
                // @ts-ignore
                assert.deepEqual(knownRelaysManager.relayFailures.get('url3'), [{
                        lastErrorTime,
                        relayManager: 'rm3',
                        relayUrl: 'url3'
                    }]);
            });
        });
        describe('DefaultRelayScore', function () {
            const failure = {
                lastErrorTime: 100,
                relayManager: 'rm3',
                relayUrl: 'url3'
            };
            it('should subtract penalty from a relay for each known failure', async function () {
                const relayScoreNoFailures = await KnownRelaysManager_1.DefaultRelayScore(relayInfoHighFee, transactionDetails, []);
                const relayScoreOneFailure = await KnownRelaysManager_1.DefaultRelayScore(relayInfoHighFee, transactionDetails, [failure]);
                const relayScoreTenFailures = await KnownRelaysManager_1.DefaultRelayScore(relayInfoHighFee, transactionDetails, Array(10).fill(failure));
                const relayScoreLowFees = await KnownRelaysManager_1.DefaultRelayScore(relayInfoLowFee, transactionDetails, []);
                assert.isAbove(relayScoreNoFailures, relayScoreOneFailure);
                assert.isAbove(relayScoreOneFailure, relayScoreTenFailures);
                assert.isAbove(relayScoreLowFees, relayScoreNoFailures);
            });
        });
    });
    describe('getRelaysSortedForTransaction', function () {
        const biasedRelayScore = async function (relay) {
            if (relay.relayUrl === 'alex') {
                return await Promise.resolve(1000);
            }
            else {
                return await Promise.resolve(100);
            }
        };
        const knownRelaysManager = new KnownRelaysManager_1.default(contractInteractor, GSNConfigurator_1.configureGSN({}), undefined, biasedRelayScore);
        before(function () {
            const activeRelays = [[], [{
                        relayManager: accounts[0],
                        relayUrl: 'alex',
                        baseRelayFee: '100000000',
                        pctRelayFee: '50'
                    }, {
                        relayManager: accounts[0],
                        relayUrl: 'joe',
                        baseRelayFee: '100',
                        pctRelayFee: '5'
                    }]];
            sinon_1.default.stub(knownRelaysManager, 'knownRelays').value(activeRelays);
        });
        it('should use provided score calculation method to sort the known relays', async function () {
            const sortedRelays = await knownRelaysManager.getRelaysSortedForTransaction(transactionDetails);
            assert.equal(sortedRelays[1][0].relayUrl, 'alex');
            assert.equal(sortedRelays[1][1].relayUrl, 'joe');
        });
    });
});
//# sourceMappingURL=KnownRelaysManager.test.js.map