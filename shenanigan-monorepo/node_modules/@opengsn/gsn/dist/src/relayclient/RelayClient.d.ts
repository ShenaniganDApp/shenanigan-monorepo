import { PrefixedHexString, Transaction } from 'ethereumjs-tx';
import { HttpProvider, TransactionReceipt } from 'web3-core';
import RelayRequest from '../common/EIP712/RelayRequest';
import TmpRelayTransactionJsonRequest from './types/TmpRelayTransactionJsonRequest';
import GsnTransactionDetails from './types/GsnTransactionDetails';
import { Address, AsyncDataCallback, PingFilter } from './types/Aliases';
import ContractInteractor from './ContractInteractor';
import { IKnownRelaysManager } from './KnownRelaysManager';
import AccountManager from './AccountManager';
import { GSNConfig, GSNDependencies } from './GSNConfigurator';
import { RelayInfo } from './types/RelayInfo';
export declare const EmptyDataCallback: AsyncDataCallback;
export declare const GasPricePingFilter: PingFilter;
interface RelayingAttempt {
    transaction?: Transaction;
    error?: Error;
}
export interface RelayingResult {
    transaction?: Transaction;
    pingErrors: Map<string, Error>;
    relayingErrors: Map<string, Error>;
}
export declare class RelayClient {
    readonly config: GSNConfig;
    private readonly httpClient;
    protected contractInteractor: ContractInteractor;
    protected knownRelaysManager: IKnownRelaysManager;
    private readonly asyncApprovalData;
    private readonly asyncPaymasterData;
    private readonly transactionValidator;
    private readonly pingFilter;
    readonly accountManager: AccountManager;
    private initialized;
    /**
     * create a RelayClient library object, to force contracts to go through a relay.
     */
    constructor(provider: HttpProvider, configOverride: Partial<GSNConfig>, overrideDependencies?: Partial<GSNDependencies>);
    /**
     * In case Relay Server does not broadcast the signed transaction to the network,
     * client also broadcasts the same transaction. If the transaction fails with nonce
     * error, it indicates Relay may have signed multiple transactions with same nonce,
     * causing a DoS attack.
     *
     * @param {*} transaction - actual Ethereum transaction, signed by a relay
     */
    _broadcastRawTx(transaction: Transaction): Promise<{
        receipt?: TransactionReceipt;
        broadcastError?: Error;
        wrongNonce?: boolean;
    }>;
    _init(): Promise<void>;
    relayTransaction(gsnTransactionDetails: GsnTransactionDetails): Promise<RelayingResult>;
    _calculateGasPrice(): Promise<PrefixedHexString>;
    _attemptRelay(relayInfo: RelayInfo, gsnTransactionDetails: GsnTransactionDetails): Promise<RelayingAttempt>;
    _prepareRelayHttpRequest(relayInfo: RelayInfo, gsnTransactionDetails: GsnTransactionDetails): Promise<{
        relayRequest: RelayRequest;
        relayMaxNonce: number;
        approvalData: PrefixedHexString;
        signature: PrefixedHexString;
        httpRequest: TmpRelayTransactionJsonRequest;
    }>;
    resolveForwarder(gsnTransactionDetails: GsnTransactionDetails): Promise<Address>;
}
export {};
