"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const ethereumjs_wallet_1 = __importDefault(require("ethereumjs-wallet"));
const eth_sig_util_1 = __importDefault(require("eth-sig-util"));
const Utils_1 = require("../common/Utils");
const web3_1 = __importDefault(require("web3"));
const TypedRequestData_1 = __importDefault(require("../common/EIP712/TypedRequestData"));
require('source-map-support').install({ errorFormatterForce: true });
function toAddress(wallet) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return `0x${wallet.getAddress().toString('hex')}`;
}
class AccountManager {
    constructor(provider, chainId, config) {
        this.accounts = [];
        this.web3 = new web3_1.default(provider);
        this.chainId = chainId;
        this.config = config;
    }
    addAccount(keypair) {
        const wallet = ethereumjs_wallet_1.default.fromPrivateKey(keypair.privateKey);
        if (!Utils_1.isSameAddress(toAddress(wallet), keypair.address)) {
            throw new Error('invalid keypair');
        }
        this.accounts.push(keypair);
    }
    newAccount() {
        const a = ethereumjs_wallet_1.default.generate();
        const keypair = {
            privateKey: a.privKey,
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            address: toAddress(a)
        };
        this.addAccount(keypair);
        return keypair;
    }
    async sign(relayRequest) {
        let signature;
        const forwarder = relayRequest.relayData.forwarder;
        const cloneRequest = Object.assign({}, relayRequest);
        const signedData = new TypedRequestData_1.default(this.chainId, forwarder, cloneRequest);
        const keypair = this.accounts.find(account => Utils_1.isSameAddress(account.address, relayRequest.request.from));
        if (keypair != null) {
            signature = this._signWithControlledKey(keypair, signedData);
        }
        else {
            signature = await this._signWithProvider(signedData);
        }
        // Sanity check only
        let rec;
        try {
            // @ts-ignore
            rec = eth_sig_util_1.default.recoverTypedSignature_v4({
                data: signedData,
                sig: signature
            });
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Failed to sign relayed transaction for ${relayRequest.request.from}: ${error}`);
        }
        if (!Utils_1.isSameAddress(relayRequest.request.from.toLowerCase(), rec)) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Internal RelayClient exception: signature is not correct: sender=${relayRequest.request.from}, recovered=${rec}`);
        }
        return signature;
    }
    // These methods is extracted to
    // a) allow different implementations in the future, and
    // b) allow spying on Account Manager in tests
    async _signWithProvider(signedData) {
        var _a, _b;
        return await Utils_1.getEip712Signature(this.web3, signedData, (_a = this.config.methodSuffix) !== null && _a !== void 0 ? _a : '', (_b = this.config.jsonStringifyRequest) !== null && _b !== void 0 ? _b : false);
    }
    _signWithControlledKey(keypair, signedData) {
        // @ts-ignore
        return eth_sig_util_1.default.signTypedData_v4(keypair.privateKey, { data: signedData });
    }
    getAccounts() {
        return this.accounts.map(it => it.address);
    }
}
exports.default = AccountManager;
//# sourceMappingURL=AccountManager.js.map