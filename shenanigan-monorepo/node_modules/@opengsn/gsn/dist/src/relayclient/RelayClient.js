"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_tx_1 = require("ethereumjs-tx");
const Constants_1 = require("../common/Constants");
const RelaySelectionManager_1 = __importDefault(require("./RelaySelectionManager"));
const GSNConfigurator_1 = require("./GSNConfigurator");
// generate "approvalData" and "paymasterData" for a request.
// both are bytes arrays. paymasterData is part of the client request.
// approvalData is created after request is filled and signed.
exports.EmptyDataCallback = async () => {
    return await Promise.resolve('0x');
};
exports.GasPricePingFilter = (pingResponse, gsnTransactionDetails) => {
    if (gsnTransactionDetails.gasPrice != null &&
        parseInt(pingResponse.MinGasPrice) > parseInt(gsnTransactionDetails.gasPrice)) {
        throw new Error(`Proposed gas price: ${gsnTransactionDetails.gasPrice}; relay's MinGasPrice: ${pingResponse.MinGasPrice}`);
    }
};
class RelayClient {
    /**
     * create a RelayClient library object, to force contracts to go through a relay.
     */
    constructor(provider, configOverride, overrideDependencies) {
        this.initialized = false;
        const config = GSNConfigurator_1.configureGSN(configOverride);
        const dependencies = GSNConfigurator_1.getDependencies(config, provider, overrideDependencies);
        this.config = dependencies.config;
        this.httpClient = dependencies.httpClient;
        this.contractInteractor = dependencies.contractInteractor;
        this.knownRelaysManager = dependencies.knownRelaysManager;
        this.transactionValidator = dependencies.transactionValidator;
        this.accountManager = dependencies.accountManager;
        this.pingFilter = dependencies.pingFilter;
        this.asyncApprovalData = dependencies.asyncApprovalData;
        this.asyncPaymasterData = dependencies.asyncPaymasterData;
    }
    /**
     * In case Relay Server does not broadcast the signed transaction to the network,
     * client also broadcasts the same transaction. If the transaction fails with nonce
     * error, it indicates Relay may have signed multiple transactions with same nonce,
     * causing a DoS attack.
     *
     * @param {*} transaction - actual Ethereum transaction, signed by a relay
     */
    async _broadcastRawTx(transaction) {
        const rawTx = '0x' + transaction.serialize().toString('hex');
        const txHash = '0x' + transaction.hash(true).toString('hex');
        if (this.config.verbose) {
            console.log('txHash= ' + txHash);
        }
        try {
            const receipt = await this.contractInteractor.sendSignedTransaction(rawTx);
            return { receipt };
        }
        catch (broadcastError) {
            // don't display error for the known-good cases
            if ((broadcastError === null || broadcastError === void 0 ? void 0 : broadcastError.message.match(/the tx doesn't have the correct nonce|known transaction/)) != null) {
                return {
                    wrongNonce: true,
                    broadcastError
                };
            }
            return { broadcastError };
        }
    }
    async _init() {
        await this.contractInteractor._init();
        this.initialized = true;
    }
    async relayTransaction(gsnTransactionDetails) {
        var _a, _b;
        if (!this.initialized) {
            await this._init();
        }
        // TODO: should have a better strategy to decide how often to refresh known relays
        await this.knownRelaysManager.refresh();
        gsnTransactionDetails.gasPrice = (_a = gsnTransactionDetails.forceGasPrice) !== null && _a !== void 0 ? _a : await this._calculateGasPrice();
        if (gsnTransactionDetails.gas == null) {
            const estimated = await this.contractInteractor.estimateGas(gsnTransactionDetails);
            gsnTransactionDetails.gas = `0x${estimated.toString(16)}`;
        }
        const relaySelectionManager = new RelaySelectionManager_1.default(gsnTransactionDetails, this.knownRelaysManager, this.httpClient, this.pingFilter, this.config);
        const relayingErrors = new Map();
        while (true) {
            let relayingAttempt;
            const activeRelay = await relaySelectionManager.selectNextRelay(gsnTransactionDetails);
            if (activeRelay != null) {
                relayingAttempt = await this._attemptRelay(activeRelay, gsnTransactionDetails);
                if (relayingAttempt.transaction == null) {
                    relayingErrors.set(activeRelay.relayInfo.relayUrl, (_b = relayingAttempt.error) !== null && _b !== void 0 ? _b : new Error('No error reason was given'));
                    continue;
                }
            }
            return {
                transaction: relayingAttempt === null || relayingAttempt === void 0 ? void 0 : relayingAttempt.transaction,
                relayingErrors,
                pingErrors: relaySelectionManager.errors
            };
        }
    }
    async _calculateGasPrice() {
        const pct = this.config.gasPriceFactorPercent;
        const networkGasPrice = await this.contractInteractor.getGasPrice();
        let gasPrice = Math.round(parseInt(networkGasPrice) * (pct + 100) / 100);
        if (this.config.minGasPrice != null && gasPrice < this.config.minGasPrice) {
            gasPrice = this.config.minGasPrice;
        }
        return `0x${gasPrice.toString(16)}`;
    }
    async _attemptRelay(relayInfo, gsnTransactionDetails) {
        if (this.config.verbose) {
            console.log(`attempting relay: ${JSON.stringify(relayInfo)} transaction: ${JSON.stringify(gsnTransactionDetails)}`);
        }
        const { relayRequest, approvalData, signature, httpRequest } = await this._prepareRelayHttpRequest(relayInfo, gsnTransactionDetails);
        const acceptRelayCallResult = await this.contractInteractor.validateAcceptRelayCall(relayRequest, signature, approvalData);
        if (!acceptRelayCallResult.paymasterAccepted) {
            let message;
            if (acceptRelayCallResult.reverted) {
                message = 'local view call to \'relayCall()\' reverted';
            }
            else {
                message = 'paymaster rejected in local view call to \'relayCall()\' ';
            }
            return { error: new Error(`${message}: ${acceptRelayCallResult.returnValue}`) };
        }
        let hexTransaction;
        try {
            hexTransaction = await this.httpClient.relayTransaction(relayInfo.relayInfo.relayUrl, httpRequest);
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.message) == null || error.message.indexOf('timeout') !== -1) {
                this.knownRelaysManager.saveRelayFailure(new Date().getTime(), relayInfo.relayInfo.relayManager, relayInfo.relayInfo.relayUrl);
            }
            if (this.config.verbose) {
                console.log('relayTransaction: ', JSON.stringify(httpRequest));
            }
            return { error };
        }
        const transaction = new ethereumjs_tx_1.Transaction(hexTransaction, this.contractInteractor.getRawTxOptions());
        if (!this.transactionValidator.validateRelayResponse(httpRequest, hexTransaction)) {
            this.knownRelaysManager.saveRelayFailure(new Date().getTime(), relayInfo.relayInfo.relayManager, relayInfo.relayInfo.relayUrl);
            return { error: new Error('Returned transaction did not pass validation') };
        }
        await this._broadcastRawTx(transaction);
        return {
            transaction
        };
    }
    async _prepareRelayHttpRequest(relayInfo, gsnTransactionDetails) {
        var _a;
        const forwarderAddress = await this.resolveForwarder(gsnTransactionDetails);
        const paymaster = gsnTransactionDetails.paymaster != null ? gsnTransactionDetails.paymaster : this.config.paymasterAddress;
        const senderNonce = await this.contractInteractor.getSenderNonce(gsnTransactionDetails.from, forwarderAddress);
        const relayWorker = relayInfo.pingResponse.RelayServerAddress;
        const gasPriceHex = gsnTransactionDetails.gasPrice;
        const gasLimitHex = gsnTransactionDetails.gas;
        if (gasPriceHex == null || gasLimitHex == null) {
            throw new Error('RelayClient internal exception. Gas price or gas limit still not calculated. Cannot happen.');
        }
        if (gasPriceHex.indexOf('0x') !== 0) {
            throw new Error(`Invalid gasPrice hex string: ${gasPriceHex}`);
        }
        if (gasLimitHex.indexOf('0x') !== 0) {
            throw new Error(`Invalid gasLimit hex string: ${gasLimitHex}`);
        }
        const gasLimit = parseInt(gasLimitHex, 16).toString();
        const gasPrice = parseInt(gasPriceHex, 16).toString();
        const value = (_a = gsnTransactionDetails.value) !== null && _a !== void 0 ? _a : '0';
        const relayRequest = {
            request: {
                to: gsnTransactionDetails.to,
                data: gsnTransactionDetails.data,
                from: gsnTransactionDetails.from,
                value: value,
                nonce: senderNonce,
                gas: gasLimit
            },
            relayData: {
                pctRelayFee: relayInfo.relayInfo.pctRelayFee,
                baseRelayFee: relayInfo.relayInfo.baseRelayFee,
                gasPrice,
                paymaster,
                paymasterData: '',
                clientId: this.config.clientId,
                forwarder: forwarderAddress,
                relayWorker
            }
        };
        const paymasterData = await this.asyncPaymasterData(relayRequest);
        // put paymasterData into struct before signing
        relayRequest.relayData.paymasterData = paymasterData;
        const signature = await this.accountManager.sign(relayRequest);
        const approvalData = await this.asyncApprovalData(relayRequest);
        // max nonce is not signed, as contracts cannot access addresses' nonces.
        const transactionCount = await this.contractInteractor.getTransactionCount(relayWorker);
        const relayMaxNonce = transactionCount + this.config.maxRelayNonceGap;
        // TODO: the server accepts a flat object, and that is why this code looks like shit.
        //  Must teach server to accept correct types
        const httpRequest = {
            relayWorker: relayInfo.pingResponse.RelayServerAddress,
            data: gsnTransactionDetails.data,
            senderNonce: relayRequest.request.nonce,
            from: gsnTransactionDetails.from,
            to: gsnTransactionDetails.to,
            pctRelayFee: relayInfo.relayInfo.pctRelayFee,
            baseRelayFee: relayInfo.relayInfo.baseRelayFee,
            value,
            gasPrice,
            gasLimit,
            paymaster: paymaster,
            paymasterData,
            clientId: this.config.clientId,
            forwarder: forwarderAddress,
            signature,
            approvalData,
            relayHubAddress: this.config.relayHubAddress,
            relayMaxNonce
        };
        if (this.config.verbose) {
            console.log(`Created HTTP relay request: ${JSON.stringify(httpRequest)}`);
        }
        return {
            relayRequest,
            relayMaxNonce,
            approvalData,
            signature,
            httpRequest
        };
    }
    async resolveForwarder(gsnTransactionDetails) {
        var _a;
        let forwarderAddress = (_a = gsnTransactionDetails.forwarder) !== null && _a !== void 0 ? _a : this.config.forwarderAddress;
        if (forwarderAddress !== Constants_1.constants.ZERO_ADDRESS) {
            const isRecipientDeployed = await this.contractInteractor.isContractDeployed(gsnTransactionDetails.to);
            if (!isRecipientDeployed) {
                console.warn(`No IRelayRecipient code at ${gsnTransactionDetails.to}, proceeding without validating 'isTrustedForwarder'!
        Unless you are using some counterfactual contract deployment technique the transaction will fail!`);
            }
            else {
                const isTrusted = await this.contractInteractor.isTrustedForwarder(gsnTransactionDetails.to, forwarderAddress);
                if (!isTrusted) {
                    throw new Error('The Forwarder address configured but is not trusted by the Recipient contract');
                }
            }
        }
        else {
            try {
                if (this.config.verbose) {
                    console.log(`will attempt to get trusted forwarder from: ${gsnTransactionDetails.to}`);
                }
                forwarderAddress = await this.contractInteractor.getForwarder(gsnTransactionDetails.to);
                if (this.config.verbose) {
                    console.log(`on-chain forwarder for: ${gsnTransactionDetails.to} is ${forwarderAddress}`);
                }
            }
            catch (e) {
                throw new Error('No forwarder address configured and no getTrustedForwarder in target contract (fetching from Recipient failed)');
            }
        }
        return forwarderAddress;
    }
}
exports.RelayClient = RelayClient;
//# sourceMappingURL=RelayClient.js.map