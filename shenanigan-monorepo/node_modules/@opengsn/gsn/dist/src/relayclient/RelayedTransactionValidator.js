"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_tx_1 = require("ethereumjs-tx");
const ethereumjs_util_1 = require("ethereumjs-util");
const Utils_1 = require("../common/Utils");
class RelayedTransactionValidator {
    constructor(contractInteractor, config) {
        this.contractInteractor = contractInteractor;
        this.config = config;
    }
    /**
     * Decode the signed transaction returned from the Relay Server, compare it to the
     * requested transaction and validate its signature.
     * @returns a signed {@link Transaction} instance for broadcasting, or null if returned
     * transaction is not valid.
     */
    validateRelayResponse(transactionJsonRequest, returnedTx) {
        const transaction = new ethereumjs_tx_1.Transaction(returnedTx, this.contractInteractor.getRawTxOptions());
        if (this.config.verbose) {
            console.log('returnedTx is', transaction.v, transaction.r, transaction.s, transaction.to, transaction.data, transaction.gasLimit, transaction.gasPrice, transaction.value);
        }
        const signer = ethereumjs_util_1.bufferToHex(transaction.getSenderAddress());
        const relayRequestOrig = {
            request: {
                to: transactionJsonRequest.to,
                data: transactionJsonRequest.data,
                gas: transactionJsonRequest.gasLimit,
                from: transactionJsonRequest.from,
                nonce: transactionJsonRequest.senderNonce,
                value: transactionJsonRequest.value
            },
            relayData: {
                gasPrice: transactionJsonRequest.gasPrice,
                baseRelayFee: transactionJsonRequest.baseRelayFee,
                pctRelayFee: transactionJsonRequest.pctRelayFee,
                relayWorker: transactionJsonRequest.relayWorker,
                forwarder: transactionJsonRequest.forwarder,
                paymaster: transactionJsonRequest.paymaster,
                paymasterData: transactionJsonRequest.paymasterData,
                clientId: transactionJsonRequest.clientId
            }
        };
        const externalGasLimit = ethereumjs_util_1.bufferToHex(transaction.gasLimit);
        const relayRequestAbiEncode = this.contractInteractor.encodeABI(relayRequestOrig, transactionJsonRequest.signature, transactionJsonRequest.approvalData, externalGasLimit);
        if (Utils_1.isSameAddress(ethereumjs_util_1.bufferToHex(transaction.to), this.config.relayHubAddress) &&
            relayRequestAbiEncode === ethereumjs_util_1.bufferToHex(transaction.data) &&
            Utils_1.isSameAddress(transactionJsonRequest.relayWorker, signer)) {
            if (this.config.verbose) {
                console.log('validateRelayResponse - valid transaction response');
            }
            // TODO: the relayServer encoder returns zero-length buffer for nonce=0.`
            const receivedNonce = transaction.nonce.length === 0 ? 0 : transaction.nonce.readUIntBE(0, transaction.nonce.byteLength);
            if (receivedNonce > transactionJsonRequest.relayMaxNonce) {
                // TODO: need to validate that client retries the same request and doesn't double-spend.
                // Note that this transaction is totally valid from the EVM's point of view
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Relay used a tx nonce higher than requested. Requested ${transactionJsonRequest.relayMaxNonce} got ${receivedNonce}`);
            }
            return true;
        }
        else {
            console.error('validateRelayResponse: req', relayRequestAbiEncode, this.config.relayHubAddress, transactionJsonRequest.relayWorker);
            console.error('validateRelayResponse: rsp', ethereumjs_util_1.bufferToHex(transaction.data), ethereumjs_util_1.bufferToHex(transaction.to), signer);
            return false;
        }
    }
}
exports.default = RelayedTransactionValidator;
//# sourceMappingURL=RelayedTransactionValidator.js.map