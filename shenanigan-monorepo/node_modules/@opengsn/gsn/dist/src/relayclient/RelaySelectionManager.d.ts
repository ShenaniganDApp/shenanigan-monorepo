import { IKnownRelaysManager } from './KnownRelaysManager';
import HttpClient from './HttpClient';
import { RelayInfoUrl } from './types/RelayRegisteredEventInfo';
import { PingFilter } from './types/Aliases';
import GsnTransactionDetails from './types/GsnTransactionDetails';
import { GSNConfig } from './GSNConfigurator';
import { PartialRelayInfo, RelayInfo } from './types/RelayInfo';
interface RaceResult {
    winner?: PartialRelayInfo;
    errors: Map<string, Error>;
}
export default class RelaySelectionManager {
    private readonly knownRelaysManager;
    private readonly httpClient;
    private readonly config;
    private readonly pingFilter;
    private readonly gsnTransactionDetails;
    private remainingRelays;
    private isInitialized;
    errors: Map<string, Error>;
    constructor(gsnTransactionDetails: GsnTransactionDetails, knownRelaysManager: IKnownRelaysManager, httpClient: HttpClient, pingFilter: PingFilter, config: GSNConfig);
    /**
     * Ping those relays that were not pinged yet, and remove both the returned relay or relays re from {@link remainingRelays}
     * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.
     */
    selectNextRelay(txDetails: GsnTransactionDetails): Promise<RelayInfo | undefined>;
    _nextRelayInternal(relays: RelayInfoUrl[]): Promise<RelayInfo | undefined>;
    _getNextSlice(txDetails: GsnTransactionDetails): Promise<RelayInfoUrl[]>;
    /**
     * @returns JSON response from the relay server, but adds the requested URL to it :'-(
     */
    _getRelayAddressPing(relayInfo: RelayInfoUrl): Promise<PartialRelayInfo>;
    /**
     * From https://stackoverflow.com/a/37235207 (added types, modified to catch exceptions)
     * Accepts an array of promises.
     * Resolves once any promise resolves, ignores the rest. Exceptions returned separately.
     */
    _raceToSuccess(relays: RelayInfoUrl[]): Promise<RaceResult>;
    _handleRaceResults(raceResult: RaceResult): void;
}
export {};
