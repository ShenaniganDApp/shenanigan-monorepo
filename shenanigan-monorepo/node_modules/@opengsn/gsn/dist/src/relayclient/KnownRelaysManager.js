"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ContractInteractor_1 = require("./ContractInteractor");
const RelayRegisteredEventInfo_1 = require("./types/RelayRegisteredEventInfo");
exports.EmptyFilter = () => {
    return true;
};
/**
 * Basic score is reversed transaction fee, higher is better.
 * Relays that failed to respond recently will be downgraded for some period of time.
 */
exports.DefaultRelayScore = async function (relay, txDetails, failures) {
    var _a, _b;
    const gasLimit = parseInt((_a = txDetails.gas) !== null && _a !== void 0 ? _a : '0');
    const gasPrice = parseInt((_b = txDetails.gasPrice) !== null && _b !== void 0 ? _b : '0');
    const pctFee = parseInt(relay.pctRelayFee);
    const baseFee = parseInt(relay.baseRelayFee);
    const transactionCost = baseFee + (gasLimit * gasPrice * (100 + pctFee)) / 100;
    let score = Math.max(Number.MAX_SAFE_INTEGER - transactionCost, 0);
    score = score * Math.pow(0.9, failures.length);
    return await Promise.resolve(score);
};
const activeManagerEvents = ['RelayServerRegistered', 'TransactionRelayed', 'TransactionRejectedByPaymaster', 'RelayWorkersAdded'];
class KnownRelaysManager {
    constructor(contractInteractor, config, relayFilter, scoreCalculator) {
        this.latestScannedBlock = 0;
        this.relayFailures = new Map();
        this.knownRelays = [];
        this.config = config;
        this.relayFilter = relayFilter !== null && relayFilter !== void 0 ? relayFilter : exports.EmptyFilter;
        this.scoreCalculator = scoreCalculator !== null && scoreCalculator !== void 0 ? scoreCalculator : exports.DefaultRelayScore;
        this.contractInteractor = contractInteractor;
    }
    async refresh() {
        this._refreshFailures();
        const recentlyActiveRelayManagers = await this._fetchRecentlyActiveRelayManagers();
        this.knownRelays[0] = this.config.preferredRelays.map(relayUrl => { return { relayUrl }; });
        this.knownRelays[1] = await this.getRelayInfoForManagers(recentlyActiveRelayManagers);
    }
    async getRelayInfoForManagers(relayManagers) {
        // As 'topics' are used as 'filter', having an empty set results in querying all register events.
        if (relayManagers.size === 0) {
            return [];
        }
        const topics = this.contractInteractor.topicsForManagers(Array.from(relayManagers));
        const relayServerRegisteredEvents = await this.contractInteractor.getPastEventsForHub([ContractInteractor_1.RelayServerRegistered], topics, { fromBlock: 1 });
        const relayManagerExitEvents = await this.contractInteractor.getPastEventsForStakeManager([ContractInteractor_1.StakeUnlocked, ContractInteractor_1.HubUnauthorized, ContractInteractor_1.StakePenalized], topics, { fromBlock: 1 });
        if (this.config.verbose) {
            console.log(`== fetchRelaysAdded: found ${relayServerRegisteredEvents.length} unique RelayAdded events`);
        }
        const mergedEvents = [...relayManagerExitEvents, ...relayServerRegisteredEvents].sort((a, b) => {
            const blockNumberA = a.blockNumber;
            const blockNumberB = b.blockNumber;
            const transactionIndexA = a.transactionIndex;
            const transactionIndexB = b.transactionIndex;
            if (blockNumberA === blockNumberB) {
                return transactionIndexA - transactionIndexB;
            }
            return blockNumberA - blockNumberB;
        });
        const activeRelays = new Map();
        mergedEvents.forEach(event => {
            const args = event.returnValues;
            if (event.event === ContractInteractor_1.RelayServerRegistered) {
                activeRelays.set(args.relayManager, args);
            }
            else {
                activeRelays.delete(args.relayManager);
            }
        });
        const origRelays = Array.from(activeRelays.values());
        return origRelays.filter(this.relayFilter);
    }
    async _fetchRecentlyActiveRelayManagers() {
        const toBlock = await this.contractInteractor.getBlockNumber();
        const fromBlock = Math.max(0, toBlock - this.config.relayLookupWindowBlocks);
        const relayEvents = await this.contractInteractor.getPastEventsForHub(activeManagerEvents, [], {
            fromBlock,
            toBlock
        });
        if (this.config.verbose) {
            console.log('fetchRelaysAdded: found ', `${relayEvents.length} events`);
        }
        const foundRelayManagers = new Set();
        relayEvents.forEach((event) => {
            // TODO: remove relay managers who are not staked
            // if (event.event === 'RelayRemoved') {
            //   foundRelays.delete(event.returnValues.relay)
            // } else {
            foundRelayManagers.add(event.returnValues.relayManager);
        });
        if (this.config.verbose) {
            console.log('fetchRelaysAdded: found unique relays:', foundRelayManagers);
        }
        this.latestScannedBlock = toBlock;
        return foundRelayManagers;
    }
    _refreshFailures() {
        const newMap = new Map();
        this.relayFailures.forEach((value, key) => {
            newMap.set(key, value.filter(failure => {
                const elapsed = (new Date().getTime() - failure.lastErrorTime) / 1000;
                return elapsed < this.config.relayTimeoutGrace;
            }));
        });
        this.relayFailures = newMap;
    }
    async getRelaysSortedForTransaction(gsnTransactionDetails) {
        const sortedRelays = [];
        for (let i = 0; i < this.knownRelays.length; i++) {
            sortedRelays[i] = await this._sortRelaysInternal(gsnTransactionDetails, this.knownRelays[i]);
        }
        return sortedRelays;
    }
    async _sortRelaysInternal(gsnTransactionDetails, activeRelays) {
        var _a;
        const scores = new Map();
        for (const activeRelay of activeRelays) {
            let score = 0;
            if (RelayRegisteredEventInfo_1.isInfoFromEvent(activeRelay)) {
                score = await this.scoreCalculator(activeRelay, gsnTransactionDetails, (_a = this.relayFailures.get(activeRelay.relayUrl)) !== null && _a !== void 0 ? _a : []);
            }
            scores.set(activeRelay.relayUrl, score);
        }
        return Array.from(activeRelays.values()).sort((a, b) => {
            var _a, _b;
            const aScore = (_a = scores.get(a.relayUrl)) !== null && _a !== void 0 ? _a : 0;
            const bScore = (_b = scores.get(b.relayUrl)) !== null && _b !== void 0 ? _b : 0;
            return bScore - aScore;
        });
    }
    saveRelayFailure(lastErrorTime, relayManager, relayUrl) {
        const relayFailures = this.relayFailures.get(relayUrl);
        const newFailureInfo = {
            lastErrorTime,
            relayManager,
            relayUrl
        };
        if (relayFailures == null) {
            this.relayFailures.set(relayUrl, [newFailureInfo]);
        }
        else {
            relayFailures.push(newFailureInfo);
        }
    }
}
exports.default = KnownRelaysManager;
//# sourceMappingURL=KnownRelaysManager.js.map