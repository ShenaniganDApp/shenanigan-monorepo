"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const Utils_1 = require("../common/Utils");
const CommandsLogic_1 = __importDefault(require("../cli/CommandsLogic"));
const KeyManager_1 = require("../relayserver/KeyManager");
const GSNConfigurator_1 = require("./GSNConfigurator");
const utils_1 = require("../cli/utils");
const TxStoreManager_1 = require("../relayserver/TxStoreManager");
const RelayServer_1 = require("../relayserver/RelayServer");
const HttpServer_1 = require("../relayserver/HttpServer");
const RelayProvider_1 = require("./RelayProvider");
const web3_1 = __importDefault(require("web3"));
const ContractInteractor_1 = __importDefault(require("./ContractInteractor"));
const Environments_1 = require("../common/Environments");
class GsnTestEnvironmentClass {
    /**
     *
     * @param host:
     * @param deployPaymaster - whether to deploy the naive paymaster instance for tests
     * @param debug
     * @return
     */
    async startGsn(host, deployPaymaster = true, debug = false) {
        var _a;
        await this.stopGsn();
        const _host = utils_1.getNetworkUrl(host);
        console.log('_host=', _host);
        if (_host == null) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`startGsn: expected network (${utils_1.supportedNetworks().join('|')}) or url`);
        }
        const commandsLogic = new CommandsLogic_1.default(_host, GSNConfigurator_1.configureGSN({}));
        const from = await commandsLogic.findWealthyAccount();
        if (from == null) {
            throw new Error('could not get unlocked account with sufficient balance');
        }
        const deploymentResult = await commandsLogic.deployGsnContracts({
            from,
            deployPaymaster,
            relayHubConfiguration: Environments_1.defaultEnvironment.relayHubConfiguration
        });
        if (deployPaymaster) {
            const balance = await commandsLogic.fundPaymaster(from, deploymentResult.naivePaymasterAddress, Utils_1.ether('1'));
            console.log('Naive Paymaster successfully funded, balance:', web3_1.default.utils.fromWei(balance));
        }
        const port = await this._resolveAvailablePort();
        const relayUrl = 'http://127.0.0.1:' + port.toString();
        this._runServer(_host, deploymentResult, from, relayUrl, port, debug);
        if (this.httpServer == null) {
            throw new Error('Failed to run a local Relay Server');
        }
        const registerOptions = {
            from,
            stake: Utils_1.ether('1'),
            funds: Utils_1.ether('1'),
            relayUrl: relayUrl,
            unstakeDelay: '2000'
        };
        const registrationResult = await commandsLogic.registerRelay(registerOptions);
        if (registrationResult.success) {
            console.log('In-process relay successfully registered:', JSON.stringify(registrationResult));
        }
        else {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Failed to fund relay: ${registrationResult.error} : ${(_a = registrationResult === null || registrationResult === void 0 ? void 0 : registrationResult.transactions) === null || _a === void 0 ? void 0 : _a.toString()}`);
        }
        await commandsLogic.waitForRelay(relayUrl);
        const config = GSNConfigurator_1.configureGSN({
            relayHubAddress: deploymentResult.relayHubAddress,
            stakeManagerAddress: deploymentResult.stakeManagerAddress,
            paymasterAddress: deploymentResult.naivePaymasterAddress,
            preferredRelays: [relayUrl]
        });
        const relayProvider = new RelayProvider_1.RelayProvider(new web3_1.default.providers.HttpProvider(_host), config);
        console.error('== startGSN: ready.');
        return {
            deploymentResult,
            relayProvider,
            relayUrl,
            httpServer: this.httpServer
        };
    }
    /**
     * initialize a local relay
     * @private
     */
    async _resolveAvailablePort() {
        const server = net_1.default.createServer();
        await new Promise(resolve => {
            server.listen(0, resolve);
        });
        const address = server.address();
        if (address == null || typeof address === 'string') {
            throw new Error('Could not find available port');
        }
        const relayListenPort = address.port;
        server.close();
        return relayListenPort;
    }
    async stopGsn() {
        if (this.httpServer !== undefined) {
            this.httpServer.stop();
            this.httpServer.close();
            await this.httpServer.backend.txStoreManager.clearAll();
            this.httpServer = undefined;
        }
    }
    _runServer(host, deploymentResult, from, relayUrl, port, debug = true) {
        if (this.httpServer !== undefined) {
            return;
        }
        const managerKeyManager = new KeyManager_1.KeyManager(1);
        const workersKeyManager = new KeyManager_1.KeyManager(1);
        const txStoreManager = new TxStoreManager_1.TxStoreManager({ inMemory: true });
        /*
          readonly contractInteractor: ContractInteractor
          readonly workerMinBalance: number | undefined // = defaultWorkerMinBalance,
          readonly workerTargetBalance: number | undefined // = defaultWorkerTargetBalance,
         */
        const interactor = new ContractInteractor_1.default(new web3_1.default.providers.HttpProvider(host), GSNConfigurator_1.configureGSN({}));
        const relayServerParams = {
            contractInteractor: interactor,
            txStoreManager,
            managerKeyManager,
            workersKeyManager,
            url: relayUrl,
            hubAddress: deploymentResult.relayHubAddress,
            gasPriceFactor: 1,
            baseRelayFee: 0,
            pctRelayFee: 0,
            devMode: true,
            debug
        };
        const backend = new RelayServer_1.RelayServer(relayServerParams);
        this.httpServer = new HttpServer_1.HttpServer(port, backend);
        this.httpServer.start();
    }
}
exports.GsnTestEnvironment = new GsnTestEnvironmentClass();
//# sourceMappingURL=GsnTestEnvironment.js.map