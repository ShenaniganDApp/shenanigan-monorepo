"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const abi_decoder_1 = __importDefault(require("abi-decoder"));
const IRelayHub_json_1 = __importDefault(require("../common/interfaces/IRelayHub.json"));
const RelayClient_1 = require("./RelayClient");
const GSNConfigurator_1 = require("./GSNConfigurator");
abi_decoder_1.default.addABI(IRelayHub_json_1.default);
class RelayProvider {
    /**
     * create a proxy provider, to relay transaction
     * @param overrideDependencies
     * @param relayClient
     * @param origProvider - the underlying web3 provider
     * @param gsnConfig
     */
    constructor(origProvider, gsnConfig, overrideDependencies, relayClient) {
        const config = GSNConfigurator_1.configureGSN(gsnConfig);
        this.host = origProvider.host;
        this.connected = origProvider.connected;
        this.origProvider = origProvider;
        this.config = config;
        if (typeof this.origProvider.sendAsync === 'function') {
            this.origProviderSend = this.origProvider.sendAsync.bind(this.origProvider);
        }
        else {
            this.origProviderSend = this.origProvider.send.bind(this.origProvider);
        }
        this.relayClient = relayClient !== null && relayClient !== void 0 ? relayClient : new RelayClient_1.RelayClient(origProvider, gsnConfig, overrideDependencies);
        this._delegateEventsApi(origProvider);
    }
    _delegateEventsApi(origProvider) {
        // If the subprovider is a ws or ipc provider, then register all its methods on this provider
        // and delegate calls to the subprovider. This allows subscriptions to work.
        ['on', 'removeListener', 'removeAllListeners', 'reset', 'disconnect', 'addDefaultEvents', 'once', 'reconnect'].forEach(func => {
            // @ts-ignore
            if (origProvider[func] !== undefined) {
                // @ts-ignore
                this[func] = origProvider[func].bind(origProvider);
            }
        });
    }
    send(payload, callback) {
        if (this._useGSN(payload)) {
            if (payload.method === 'eth_sendTransaction') {
                if (payload.params[0].to === undefined) {
                    throw new Error('GSN cannot relay contract deployment transactions. Add {from: accountWithEther, useGSN: false}.');
                }
                this._ethSendTransaction(payload, callback);
                return;
            }
            if (payload.method === 'eth_getTransactionReceipt') {
                this._ethGetTransactionReceipt(payload, callback);
                return;
            }
            if (payload.method === 'eth_accounts') {
                this._getAccounts(payload, callback);
            }
        }
        this.origProviderSend(payload, (error, result) => {
            callback(error, result);
        });
    }
    _ethGetTransactionReceipt(payload, callback) {
        if (this.config.verbose) {
            console.log('calling sendAsync' + JSON.stringify(payload));
        }
        this.origProviderSend(payload, (error, rpcResponse) => {
            // Sometimes, ganache seems to return 'false' for 'no error' (breaking TypeScript declarations)
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (error) {
                callback(error, rpcResponse);
                return;
            }
            if (rpcResponse == null || rpcResponse.result == null) {
                console.error('Empty JsonRpcResponse with no error message');
                callback(error, rpcResponse);
                return;
            }
            rpcResponse.result = this._getTranslatedGsnResponseResult(rpcResponse.result);
            callback(error, rpcResponse);
        });
    }
    _ethSendTransaction(payload, callback) {
        if (this.config.verbose) {
            console.log('calling sendAsync' + JSON.stringify(payload));
        }
        const gsnTransactionDetails = payload.params[0];
        this.relayClient.relayTransaction(gsnTransactionDetails)
            .then((relayingResult) => {
            if (relayingResult.transaction != null) {
                const jsonRpcSendResult = this._convertTransactionToRpcSendResponse(relayingResult.transaction, payload);
                callback(null, jsonRpcSendResult);
            }
            else {
                const message = `Failed to relay call. Results:\n${this._dumpRelayingResult(relayingResult)}`;
                if (this.config.verbose) {
                    console.error(message);
                }
                callback(new Error(message));
            }
        }, (reason) => {
            const reasonStr = reason instanceof Error ? reason.message : JSON.stringify(reason);
            callback(new Error(`Rejected relayTransaction call - should not happen. Reason: ${reasonStr}`));
        });
    }
    _convertTransactionToRpcSendResponse(transaction, request) {
        var _a;
        const txHash = transaction.hash(true).toString('hex');
        const hash = `0x${txHash}`;
        const id = (_a = (typeof request.id === 'string' ? parseInt(request.id) : request.id)) !== null && _a !== void 0 ? _a : -1;
        return {
            jsonrpc: '2.0',
            id,
            result: hash
        };
    }
    _getTranslatedGsnResponseResult(respResult) {
        const fixedTransactionReceipt = Object.assign({}, respResult);
        if (respResult.logs.length === 0) {
            return fixedTransactionReceipt;
        }
        const logs = abi_decoder_1.default.decodeLogs(respResult.logs);
        const paymasterRejectedEvents = logs.find((e) => e != null && e.name === 'TransactionRejectedByPaymaster');
        if (paymasterRejectedEvents !== null && paymasterRejectedEvents !== undefined) {
            const paymasterRejectionReason = paymasterRejectedEvents.events.find((e) => e.name === 'reason');
            if (paymasterRejectionReason !== undefined) {
                if (this.config.verbose) {
                    console.log(`Paymaster rejected on-chain: ${paymasterRejectionReason.value}. changing status to zero`);
                }
                fixedTransactionReceipt.status = '0';
            }
            return fixedTransactionReceipt;
        }
        const transactionRelayed = logs.find((e) => e != null && e.name === 'TransactionRelayed');
        if (transactionRelayed != null) {
            const transactionRelayedStatus = transactionRelayed.events.find((e) => e.name === 'status');
            if (transactionRelayedStatus !== undefined) {
                const status = transactionRelayedStatus.value.toString();
                // 0 signifies success
                if (status !== '0') {
                    if (this.config.verbose) {
                        console.log(`reverted relayed transaction, status code ${status}. changing status to zero`);
                    }
                    fixedTransactionReceipt.status = '0';
                }
            }
        }
        return fixedTransactionReceipt;
    }
    _useGSN(payload) {
        var _a;
        if (payload.method === 'eth_accounts') {
            return true;
        }
        if (payload.params[0] === undefined) {
            return false;
        }
        const gsnTransactionDetails = payload.params[0];
        return (_a = gsnTransactionDetails === null || gsnTransactionDetails === void 0 ? void 0 : gsnTransactionDetails.useGSN) !== null && _a !== void 0 ? _a : true;
    }
    _dumpRelayingResult(relayingResult) {
        let str = `Ping errors (${relayingResult.pingErrors.size}):`;
        Array.from(relayingResult.pingErrors.keys()).forEach(e => {
            var _a, _b;
            const error = (_b = (_a = relayingResult.pingErrors.get(e)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
            str += `\n${e} => ${error}\n`;
        });
        str += `Relaying errors (${relayingResult.relayingErrors.size}):\n`;
        Array.from(relayingResult.relayingErrors.keys()).forEach(e => {
            var _a, _b;
            const error = (_b = (_a = relayingResult.relayingErrors.get(e)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
            str += `${e} => ${error}`;
        });
        return str;
    }
    supportsSubscriptions() {
        return this.origProvider.supportsSubscriptions();
    }
    disconnect() {
        return this.origProvider.disconnect();
    }
    newAccount() {
        return this.relayClient.accountManager.newAccount();
    }
    addAccount(keypair) {
        this.relayClient.accountManager.addAccount(keypair);
    }
    _getAccounts(payload, callback) {
        this.origProviderSend(payload, (error, rpcResponse) => {
            if (rpcResponse != null && Array.isArray(rpcResponse.result)) {
                const ephemeralAccounts = this.relayClient.accountManager.getAccounts();
                rpcResponse.result = rpcResponse.result.concat(ephemeralAccounts);
            }
            callback(error, rpcResponse);
        });
    }
}
exports.RelayProvider = RelayProvider;
//# sourceMappingURL=RelayProvider.js.map