"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_1 = __importDefault(require("web3"));
const IPaymaster_json_1 = __importDefault(require("../common/interfaces/IPaymaster.json"));
const IRelayHub_json_1 = __importDefault(require("../common/interfaces/IRelayHub.json"));
const IForwarder_json_1 = __importDefault(require("../common/interfaces/IForwarder.json"));
const IStakeManager_json_1 = __importDefault(require("../common/interfaces/IStakeManager.json"));
const IRelayRecipient_json_1 = __importDefault(require("../common/interfaces/IRelayRecipient.json"));
const IKnowForwarderAddress_json_1 = __importDefault(require("../common/interfaces/IKnowForwarderAddress.json"));
const Utils_1 = require("../common/Utils");
const Constants_1 = require("../common/Constants");
const ErrorReplacerJSON_1 = __importDefault(require("../common/ErrorReplacerJSON"));
const VersionsManager_1 = __importDefault(require("../common/VersionsManager"));
const ethereumjs_common_1 = __importDefault(require("ethereumjs-common"));
// Truffle Contract typings seem to be completely out of their minds
const TruffleContract = require("@truffle/contract");
exports.RelayServerRegistered = 'RelayServerRegistered';
exports.StakeUnlocked = 'StakeUnlocked';
exports.HubUnauthorized = 'HubUnauthorized';
exports.StakePenalized = 'StakePenalized';
class ContractInteractor {
    constructor(provider, config) {
        this.VERSION = '2.0.0-alpha.3';
        this.versionManager = new VersionsManager_1.default(this.VERSION);
        this.web3 = new web3_1.default(provider);
        this.config = config;
        this.provider = provider;
        // @ts-ignore
        this.IPaymasterContract = TruffleContract({
            contractName: 'IPaymaster',
            abi: IPaymaster_json_1.default
        });
        // @ts-ignore
        this.IRelayHubContract = TruffleContract({
            contractName: 'IRelayHub',
            abi: IRelayHub_json_1.default
        });
        // @ts-ignore
        this.IForwarderContract = TruffleContract({
            contractName: 'IForwarder',
            abi: IForwarder_json_1.default
        });
        // @ts-ignore
        this.IStakeManager = TruffleContract({
            contractName: 'IStakeManager',
            abi: IStakeManager_json_1.default
        });
        // @ts-ignore
        this.IRelayRecipient = TruffleContract({
            contractName: 'IRelayRecipient',
            abi: IRelayRecipient_json_1.default
        });
        // @ts-ignore
        this.IKnowForwarderAddress = TruffleContract({
            contractName: 'IKnowForwarderAddress',
            abi: IKnowForwarderAddress_json_1.default
        });
        this.IStakeManager.setProvider(this.provider, undefined);
        this.IRelayHubContract.setProvider(this.provider, undefined);
        this.IPaymasterContract.setProvider(this.provider, undefined);
        this.IForwarderContract.setProvider(this.provider, undefined);
        this.IRelayRecipient.setProvider(this.provider, undefined);
        this.IKnowForwarderAddress.setProvider(this.provider, undefined);
    }
    getProvider() { return this.provider; }
    getWeb3() { return this.web3; }
    async _init() {
        await this._validateCompatibility();
        const chain = await this.web3.eth.net.getNetworkType();
        this.chainId = await this.web3.eth.getChainId();
        this.networkId = await this.web3.eth.net.getId();
        this.networkType = await this.web3.eth.net.getNetworkType();
        // chain === 'private' means we're on ganache, and ethereumjs-tx.Transaction doesn't support that chain type
        this.rawTxOptions = getRawTxOptions(this.chainId, this.networkId, chain);
    }
    async _validateCompatibility() {
        if (this.config.relayHubAddress === Constants_1.constants.ZERO_ADDRESS) {
            return;
        }
        const hub = await this._createRelayHub(this.config.relayHubAddress);
        const version = await hub.versionHub();
        const isNewer = this.versionManager.isMinorSameOrNewer(version);
        if (!isNewer) {
            throw new Error(`Provided Hub version(${version}) is not supported by the current interactor(${this.VERSION})`);
        }
    }
    // must use these options when creating Transaction object
    getRawTxOptions() {
        if (this.rawTxOptions == null) {
            throw new Error('_init not called');
        }
        return this.rawTxOptions;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createKnowsForwarder(address) {
        return await this.IKnowForwarderAddress.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createRecipient(address) {
        return await this.IRelayRecipient.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createPaymaster(address) {
        return await this.IPaymasterContract.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createRelayHub(address) {
        return await this.IRelayHubContract.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createForwarder(address) {
        return await this.IForwarderContract.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createStakeManager(address) {
        return await this.IStakeManager.at(address);
    }
    async getForwarder(recipientAddress) {
        const recipient = await this._createKnowsForwarder(recipientAddress);
        return await recipient.getTrustedForwarder();
    }
    async isTrustedForwarder(recipientAddress, forwarder) {
        const recipient = await this._createRecipient(recipientAddress);
        return await recipient.isTrustedForwarder(forwarder);
    }
    async getSenderNonce(sender, forwarderAddress) {
        const forwarder = await this._createForwarder(forwarderAddress);
        const nonce = await forwarder.getNonce(sender);
        return nonce.toString();
    }
    async _getBlockGasLimit() {
        const latestBlock = await this.web3.eth.getBlock('latest');
        return latestBlock.gasLimit;
    }
    async validateAcceptRelayCall(relayRequest, signature, approvalData) {
        const relayHub = await this._createRelayHub(this.config.relayHubAddress);
        try {
            const externalGasLimit = await this._getBlockGasLimit();
            const res = await relayHub.contract.methods.relayCall(relayRequest, signature, approvalData, externalGasLimit)
                .call({
                from: relayRequest.relayData.relayWorker,
                gasPrice: relayRequest.relayData.gasPrice,
                gas: externalGasLimit
            });
            if (this.config.verbose) {
                console.log(res);
            }
            return {
                returnValue: res.returnValue,
                paymasterAccepted: res.paymasterAccepted,
                reverted: false
            };
        }
        catch (e) {
            const message = e instanceof Error ? e.message : JSON.stringify(e, ErrorReplacerJSON_1.default);
            return {
                paymasterAccepted: false,
                reverted: true,
                returnValue: `view call to 'relayCall' reverted in client (should not happen): ${message}`
            };
        }
    }
    encodeABI(relayRequest, sig, approvalData, externalGasLimit) {
        // TODO: check this works as expected
        // @ts-ignore
        const relayHub = new this.IRelayHubContract('');
        return relayHub.contract.methods.relayCall(relayRequest, sig, approvalData, externalGasLimit).encodeABI();
    }
    topicsForManagers(relayManagers) {
        return Array.from(relayManagers.values(), (address) => `0x${address.replace(/^0x/, '').padStart(64, '0').toLowerCase()}`);
    }
    async getPastEventsForHub(names, extraTopics, options) {
        const relayHub = await this._createRelayHub(this.config.relayHubAddress);
        return await this._getPastEvents(relayHub.contract, names, extraTopics, options);
    }
    async getPastEventsForStakeManager(names, extraTopics, options) {
        const stakeManager = await this._createStakeManager(this.config.stakeManagerAddress);
        return await this._getPastEvents(stakeManager.contract, names, extraTopics, options);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _getPastEvents(contract, names, extraTopics, options) {
        const topics = [];
        const eventTopic = Utils_1.event2topic(contract, names);
        topics.push(eventTopic);
        if (extraTopics.length > 0) {
            topics.push(extraTopics);
        }
        return contract.getPastEvents('allEvents', Object.assign({}, options, { topics }));
    }
    async getPastLogs(options) {
        return await this.web3.eth.getPastLogs(options);
    }
    async getBalance(address) {
        return await this.web3.eth.getBalance(address);
    }
    async getBlockNumber() {
        return await this.web3.eth.getBlockNumber();
    }
    async sendSignedTransaction(rawTx) {
        return await this.web3.eth.sendSignedTransaction(rawTx);
    }
    async estimateGas(gsnTransactionDetails) {
        return await this.web3.eth.estimateGas(gsnTransactionDetails);
    }
    async getGasPrice() {
        return await this.web3.eth.getGasPrice();
    }
    async getTransactionCount(address, defaultBlock) {
        // @ts-ignore (web3 does not define 'defaultBlock' as optional)
        return await this.web3.eth.getTransactionCount(address, defaultBlock);
    }
    async getTransaction(transactionHash) {
        return await this.web3.eth.getTransaction(transactionHash);
    }
    async getBlock(blockHashOrBlockNumber) {
        return await this.web3.eth.getBlock(blockHashOrBlockNumber);
    }
    async getCode(address) {
        return await this.web3.eth.getCode(address);
    }
    getChainId() {
        if (this.chainId == null) {
            throw new Error('_init not called');
        }
        return this.chainId;
    }
    getNetworkId() {
        if (this.networkId == null) {
            throw new Error('_init not called');
        }
        return this.networkId;
    }
    getNetworkType() {
        if (this.networkType == null) {
            throw new Error('_init not called');
        }
        return this.networkType;
    }
    async isContractDeployed(address) {
        const code = await this.web3.eth.getCode(address);
        return code !== '0x';
    }
}
exports.default = ContractInteractor;
/**
 * Ganache does not seem to enforce EIP-155 signature. Buidler does, though.
 * This is how {@link Transaction} constructor allows support for custom and private network.
 * @param chainId
 * @param networkId
 * @param chain
 * @return {{common: Common}}
 */
function getRawTxOptions(chainId, networkId, chain) {
    if (chain == null || chain === 'main' || chain === 'private') {
        chain = 'mainnet';
    }
    return {
        common: ethereumjs_common_1.default.forCustomChain(chain, {
            chainId,
            networkId
        }, 'istanbul')
    };
}
exports.getRawTxOptions = getRawTxOptions;
//# sourceMappingURL=ContractInteractor.js.map