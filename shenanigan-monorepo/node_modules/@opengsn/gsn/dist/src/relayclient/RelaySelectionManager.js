"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RelayRegisteredEventInfo_1 = require("./types/RelayRegisteredEventInfo");
const ErrorReplacerJSON_1 = __importDefault(require("../common/ErrorReplacerJSON"));
class RelaySelectionManager {
    constructor(gsnTransactionDetails, knownRelaysManager, httpClient, pingFilter, config) {
        this.remainingRelays = [];
        this.isInitialized = false;
        this.errors = new Map();
        this.gsnTransactionDetails = gsnTransactionDetails;
        this.knownRelaysManager = knownRelaysManager;
        this.httpClient = httpClient;
        this.pingFilter = pingFilter;
        this.config = config;
    }
    /**
     * Ping those relays that were not pinged yet, and remove both the returned relay or relays re from {@link remainingRelays}
     * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.
     */
    async selectNextRelay(txDetails) {
        while (true) {
            const slice = await this._getNextSlice(txDetails);
            let relayInfo;
            if (slice.length > 0) {
                relayInfo = await this._nextRelayInternal(slice);
                if (relayInfo == null) {
                    continue;
                }
            }
            return relayInfo;
        }
    }
    async _nextRelayInternal(relays) {
        if (this.config.verbose) {
            console.log('nextRelay: find fastest relay from: ' + JSON.stringify(relays));
        }
        const raceResult = await this._raceToSuccess(relays);
        if (this.config.verbose) {
            console.log(`race finished with a result: ${JSON.stringify(raceResult, ErrorReplacerJSON_1.default)}`);
        }
        this._handleRaceResults(raceResult);
        if (raceResult.winner != null) {
            if (RelayRegisteredEventInfo_1.isInfoFromEvent(raceResult.winner.relayInfo)) {
                return raceResult.winner;
            }
            else {
                const managerAddress = raceResult.winner.pingResponse.RelayManagerAddress;
                if (this.config.verbose) {
                    console.log(`finding relay register info for manager address: ${managerAddress}; known info: ${JSON.stringify(raceResult.winner.relayInfo)}`);
                }
                const events = await this.knownRelaysManager.getRelayInfoForManagers(new Set([managerAddress]));
                if (events.length === 1) {
                    return {
                        pingResponse: raceResult.winner.pingResponse,
                        relayInfo: events[0]
                    };
                }
                else {
                    // TODO: do not throw! The preffered relay may be removed since.
                    throw new Error('Could not find register event for the winning preferred relay');
                }
            }
        }
    }
    async _getNextSlice(txDetails) {
        if (!this.isInitialized) {
            this.remainingRelays = await this.knownRelaysManager.getRelaysSortedForTransaction(txDetails);
            this.isInitialized = true;
        }
        for (const relays of this.remainingRelays) {
            const bulkSize = Math.min(this.config.sliceSize, relays.length);
            const slice = relays.slice(0, bulkSize);
            if (slice.length === 0) {
                continue;
            }
            // we must verify uniqueness of URLs as they are used as keys in maps
            // https://stackoverflow.com/a/45125209
            slice.filter((e1, i) => slice.findIndex((e2) => e1.relayUrl === e2.relayUrl) === i);
            return slice;
        }
        return [];
    }
    /**
     * @returns JSON response from the relay server, but adds the requested URL to it :'-(
     */
    async _getRelayAddressPing(relayInfo) {
        if (this.config.verbose) {
            console.log(`getRelayAddressPing URL: ${relayInfo.relayUrl}`);
        }
        const pingResponse = await this.httpClient.getPingResponse(relayInfo.relayUrl);
        if (!pingResponse.Ready) {
            throw new Error(`Relay not ready ${JSON.stringify(pingResponse)}`);
        }
        this.pingFilter(pingResponse, this.gsnTransactionDetails);
        return {
            pingResponse,
            relayInfo
        };
    }
    /**
     * From https://stackoverflow.com/a/37235207 (added types, modified to catch exceptions)
     * Accepts an array of promises.
     * Resolves once any promise resolves, ignores the rest. Exceptions returned separately.
     */
    async _raceToSuccess(relays) {
        const errors = new Map();
        return await new Promise((resolve) => {
            relays.forEach((relay) => {
                this._getRelayAddressPing(relay)
                    .then((winner) => {
                    resolve({
                        winner,
                        errors
                    });
                })
                    .catch((err) => {
                    errors.set(relay.relayUrl, err);
                    if (errors.size === relays.length) {
                        resolve({ errors });
                    }
                });
            });
        });
    }
    _handleRaceResults(raceResult) {
        this.errors = new Map([...this.errors, ...raceResult.errors]);
        this.remainingRelays = this.remainingRelays.map(relays => relays
            .filter(eventInfo => { var _a; return eventInfo.relayUrl !== ((_a = raceResult.winner) === null || _a === void 0 ? void 0 : _a.relayInfo.relayUrl); })
            .filter(eventInfo => !Array.from(raceResult.errors.keys()).includes(eventInfo.relayUrl)));
    }
}
exports.default = RelaySelectionManager;
//# sourceMappingURL=RelaySelectionManager.js.map