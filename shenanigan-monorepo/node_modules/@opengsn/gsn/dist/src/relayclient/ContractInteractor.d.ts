import Web3 from 'web3';
import { BlockNumber, Log, PastLogsOptions, provider, Transaction, TransactionReceipt } from 'web3-core';
import { EventData, PastEventOptions } from 'web3-eth-contract';
import { PrefixedHexString, TransactionOptions } from 'ethereumjs-tx';
import RelayRequest from '../common/EIP712/RelayRequest';
import { IKnowForwarderAddressInstance, IPaymasterInstance, IRelayHubInstance, IRelayRecipientInstance, IStakeManagerInstance, IForwarderInstance } from '../../types/truffle-contracts';
import { Address, IntString } from './types/Aliases';
import { GSNConfig } from './GSNConfigurator';
import GsnTransactionDetails from './types/GsnTransactionDetails';
import { BlockTransactionString } from 'web3-eth';
declare type EventName = string;
export declare const RelayServerRegistered: EventName;
export declare const StakeUnlocked: EventName;
export declare const HubUnauthorized: EventName;
export declare const StakePenalized: EventName;
export default class ContractInteractor {
    private readonly VERSION;
    private readonly IPaymasterContract;
    private readonly IRelayHubContract;
    private readonly IForwarderContract;
    private readonly IStakeManager;
    private readonly IRelayRecipient;
    private readonly IKnowForwarderAddress;
    private readonly web3;
    private readonly provider;
    private readonly config;
    private readonly versionManager;
    private rawTxOptions?;
    private chainId?;
    private networkId?;
    private networkType?;
    constructor(provider: provider, config: GSNConfig);
    getProvider(): provider;
    getWeb3(): Web3;
    _init(): Promise<void>;
    _validateCompatibility(): Promise<void>;
    getRawTxOptions(): TransactionOptions;
    _createKnowsForwarder(address: Address): Promise<IKnowForwarderAddressInstance>;
    _createRecipient(address: Address): Promise<IRelayRecipientInstance>;
    _createPaymaster(address: Address): Promise<IPaymasterInstance>;
    _createRelayHub(address: Address): Promise<IRelayHubInstance>;
    _createForwarder(address: Address): Promise<IForwarderInstance>;
    _createStakeManager(address: Address): Promise<IStakeManagerInstance>;
    getForwarder(recipientAddress: Address): Promise<Address>;
    isTrustedForwarder(recipientAddress: Address, forwarder: Address): Promise<boolean>;
    getSenderNonce(sender: Address, forwarderAddress: Address): Promise<IntString>;
    _getBlockGasLimit(): Promise<number>;
    validateAcceptRelayCall(relayRequest: RelayRequest, signature: PrefixedHexString, approvalData: PrefixedHexString): Promise<{
        paymasterAccepted: boolean;
        returnValue: string;
        reverted: boolean;
    }>;
    encodeABI(relayRequest: RelayRequest, sig: PrefixedHexString, approvalData: PrefixedHexString, externalGasLimit: IntString): PrefixedHexString;
    topicsForManagers(relayManagers: Address[]): string[];
    getPastEventsForHub(names: EventName[], extraTopics: string[], options: PastEventOptions): Promise<EventData[]>;
    getPastEventsForStakeManager(names: EventName[], extraTopics: string[], options: PastEventOptions): Promise<EventData[]>;
    _getPastEvents(contract: any, names: EventName[], extraTopics: string[], options: PastEventOptions): Promise<EventData[]>;
    getPastLogs(options: PastLogsOptions): Promise<Log[]>;
    getBalance(address: Address): Promise<string>;
    getBlockNumber(): Promise<number>;
    sendSignedTransaction(rawTx: string): Promise<TransactionReceipt>;
    estimateGas(gsnTransactionDetails: GsnTransactionDetails): Promise<number>;
    getGasPrice(): Promise<string>;
    getTransactionCount(address: string, defaultBlock?: BlockNumber): Promise<number>;
    getTransaction(transactionHash: string): Promise<Transaction>;
    getBlock(blockHashOrBlockNumber: BlockNumber): Promise<BlockTransactionString>;
    getCode(address: string): Promise<string>;
    getChainId(): number;
    getNetworkId(): number;
    getNetworkType(): string;
    isContractDeployed(address: Address): Promise<boolean>;
}
/**
 * Ganache does not seem to enforce EIP-155 signature. Buidler does, though.
 * This is how {@link Transaction} constructor allows support for custom and private network.
 * @param chainId
 * @param networkId
 * @param chain
 * @return {{common: Common}}
 */
export declare function getRawTxOptions(chainId: number, networkId: number, chain?: string): TransactionOptions;
export {};
