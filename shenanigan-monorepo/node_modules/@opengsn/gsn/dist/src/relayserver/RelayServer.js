"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const ow_1 = __importDefault(require("ow"));
// @ts-ignore
const abi_decoder_1 = __importDefault(require("abi-decoder"));
const ethereumjs_tx_1 = require("ethereumjs-tx");
const IRelayHub_json_1 = __importDefault(require("../common/interfaces/IRelayHub.json"));
const IPaymaster_json_1 = __importDefault(require("../common/interfaces/IPaymaster.json"));
const IStakeManager_json_1 = __importDefault(require("../common/interfaces/IStakeManager.json"));
const TxStoreManager_1 = require("./TxStoreManager");
const async_mutex_1 = require("async-mutex");
const web3_utils_1 = require("web3-utils");
const Environments_1 = require("../common/Environments");
const VersionsManager_1 = __importDefault(require("../common/VersionsManager"));
const Utils_1 = require("../common/Utils");
abi_decoder_1.default.addABI(IRelayHub_json_1.default);
abi_decoder_1.default.addABI(IPaymaster_json_1.default);
abi_decoder_1.default.addABI(IStakeManager_json_1.default);
const mintxgascost = Environments_1.defaultEnvironment.mintxgascost;
const VERSION = '2.0.0-alpha.3';
const minimumRelayBalance = 1e17; // 0.1 eth
const defaultWorkerMinBalance = 0.01e18;
const defaultWorkerTargetBalance = 0.3e18;
const confirmationsNeeded = 12;
const pendingTransactionTimeout = 5 * 60 * 1000; // 5 minutes in milliseconds
const maxGasPrice = 100e9;
const GAS_RESERVE = 100000;
const retryGasPriceFactor = 1.2;
let DEBUG = false;
const SPAM = false;
function debug(...args) {
    if (DEBUG)
        console.log(...args);
}
function spam(...args) {
    if (SPAM)
        debug(...args);
}
class StateError extends Error {
}
class RelayServer extends events_1.EventEmitter {
    constructor(params) {
        var _a, _b, _c, _d, _e, _f, _g;
        super();
        this.lastScannedBlock = 0;
        this.ready = false;
        this.nonceMutex = new async_mutex_1.Mutex();
        this.nonces = {};
        this.gasPrice = 0;
        this._workerSemaphoreOn = false;
        this.initialized = false;
        this.stake = web3_utils_1.toBN(0);
        this.authorizedHub = false;
        this.versionManager = new VersionsManager_1.default(VERSION);
        this.txStoreManager = params.txStoreManager;
        this.workersKeyManager = params.workersKeyManager;
        this.managerKeyManager = params.managerKeyManager;
        this.hubAddress = params.hubAddress;
        this.trustedPaymasters = (_b = (_a = params.trustedPaymasters) === null || _a === void 0 ? void 0 : _a.map(e => e.toLowerCase())) !== null && _b !== void 0 ? _b : [];
        this.baseRelayFee = (_c = params.baseRelayFee) !== null && _c !== void 0 ? _c : 0;
        this.pctRelayFee = (_d = params.pctRelayFee) !== null && _d !== void 0 ? _d : 0;
        this.gasPriceFactor = params.gasPriceFactor;
        this.url = (_e = params.url) !== null && _e !== void 0 ? _e : 'http://localhost:8090';
        this.workerMinBalance = (_f = params.workerMinBalance) !== null && _f !== void 0 ? _f : defaultWorkerMinBalance;
        this.workerTargetBalance = (_g = params.workerTargetBalance) !== null && _g !== void 0 ? _g : defaultWorkerTargetBalance;
        this.devMode = params.devMode;
        this.contractInteractor = params.contractInteractor;
        DEBUG = params.debug;
        this.managerAddress = this.managerKeyManager.getAddress(0);
        // todo: initialize nonces for all signers (currently one manager, one worker)
        this.nonces = {};
        this.nonces[this.managerKeyManager.getAddress(0)] = 0;
        this.nonces[this.workersKeyManager.getAddress(0)] = 0;
        debug('gasPriceFactor', this.gasPriceFactor);
    }
    getManagerAddress() {
        return this.managerAddress;
    }
    getWorkerAddress(index) {
        ow_1.default(index, ow_1.default.number);
        return this.workersKeyManager.getAddress(index);
    }
    getMinGasPrice() {
        return this.gasPrice;
    }
    isReady() {
        return this.ready;
    }
    pingHandler() {
        var _a, _b;
        return {
            RelayServerAddress: this.getWorkerAddress(0),
            RelayManagerAddress: this.managerAddress,
            RelayHubAddress: (_b = (_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '',
            MinGasPrice: this.getMinGasPrice().toString(),
            Ready: this.isReady(),
            Version: VERSION
        };
    }
    async createRelayTransaction(req) {
        var _a, _b, _c, _d, _e;
        debug('dump request params', arguments[0]);
        ow_1.default(req.data, ow_1.default.string);
        ow_1.default(req.approvalData, ow_1.default.string);
        ow_1.default(req.signature, ow_1.default.string);
        // Check that the relayHub is the correct one
        if (req.relayHubAddress !== ((_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.address)) {
            throw new Error(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Wrong hub address.\nRelay server's hub address: ${(_b = this.relayHubContract) === null || _b === void 0 ? void 0 : _b.address}, request's hub address: ${req.relayHubAddress}\n`);
        }
        // Check the relayWorker (todo: once migrated to multiple relays, check if exists)
        const workerIndex = 0;
        if (req.relayWorker.toLowerCase() !== this.getWorkerAddress(workerIndex).toLowerCase()) {
            throw new Error(`Wrong worker address: ${req.relayWorker}\n`);
        }
        // if trusted paymaster, we trust it to handle fees
        if (!this.trustedPaymasters.includes(req.paymaster.toLowerCase())) {
            // Check that the fee is acceptable
            if (isNaN(parseInt(req.pctRelayFee)) || parseInt(req.pctRelayFee) < this.pctRelayFee) {
                throw new Error(`Unacceptable pctRelayFee: ${req.pctRelayFee} relayServer's pctRelayFee: ${this.pctRelayFee}`);
            }
            if (isNaN(parseInt(req.baseRelayFee)) || parseInt(req.baseRelayFee) < this.baseRelayFee) {
                throw new Error(`Unacceptable baseRelayFee: ${req.baseRelayFee} relayServer's baseRelayFee: ${this.baseRelayFee}`);
            }
        }
        // Check that the gasPrice is initialized & acceptable
        if (this.gasPrice === 0 || this.gasPrice == null) {
            throw new Error('gasPrice not initialized');
        }
        if (this.gasPrice > parseInt((_c = req.gasPrice) !== null && _c !== void 0 ? _c : '0')) {
            throw new Error(`Unacceptable gasPrice: relayServer's gasPrice:${this.gasPrice} request's gasPrice: ${req.gasPrice}`);
        }
        // Check that max nonce is valid
        const nonce = await this._pollNonce(this.getWorkerAddress(workerIndex));
        if (nonce > req.relayMaxNonce) {
            throw new Error(`Unacceptable relayMaxNonce: ${req.relayMaxNonce}. current nonce: ${nonce}`);
        }
        // Call relayCall as a view function to see if we'll get paid for relaying this tx
        const relayRequest = {
            request: {
                to: req.to,
                data: req.data,
                from: req.from,
                nonce: req.senderNonce,
                gas: req.gasLimit,
                value: req.value
            },
            relayData: {
                baseRelayFee: req.baseRelayFee,
                pctRelayFee: req.pctRelayFee,
                gasPrice: req.gasPrice,
                paymaster: req.paymaster,
                paymasterData: req.paymasterData,
                clientId: req.clientId,
                forwarder: req.forwarder,
                relayWorker: this.getWorkerAddress(workerIndex)
            }
        };
        let gasLimits;
        try {
            if (this.paymasterContract === undefined) {
                this.paymasterContract = await this.contractInteractor._createPaymaster(req.paymaster);
            }
            this.paymasterContract.contract.options.address = req.paymaster;
            gasLimits = await this.paymasterContract.getGasLimits();
        }
        catch (e) {
            if (
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            e.message.includes('Returned values aren\'t valid, did it run Out of Gas?')) {
                throw new Error(`non-existent or incompatible paymaster contract: ${req.paymaster}`);
            }
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`unknown paymaster error: ${e.message}`);
        }
        const hubOverhead = (await this.relayHubContract.gasOverhead()).toNumber();
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        const maxPossibleGas = GAS_RESERVE + Utils_1.calculateTransactionMaxPossibleGas({
            gasLimits,
            hubOverhead,
            relayCallGasLimit: req.gasLimit
        });
        const method = this.relayHubContract.contract.methods.relayCall(relayRequest, req.signature, req.approvalData, maxPossibleGas);
        let viewRelayCallRet;
        try {
            viewRelayCallRet = await this.relayHubContract.contract.methods.relayCall(relayRequest, req.signature, req.approvalData, maxPossibleGas)
                .call({
                from: this.getWorkerAddress(workerIndex),
                gasPrice: relayRequest.relayData.gasPrice,
                gasLimit: maxPossibleGas
            });
        }
        catch (e) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`relayCall reverted in server: ${e.message}`);
        }
        debug('viewRelayCallRet', viewRelayCallRet);
        if (!viewRelayCallRet.paymasterAccepted) {
            throw new Error(`Paymaster rejected in server: ${viewRelayCallRet.returnValue} req=${JSON.stringify(relayRequest, null, 2)}`);
        }
        // Send relayed transaction
        debug('maxPossibleGas is', typeof maxPossibleGas, maxPossibleGas);
        const maxCharge = 
        // @ts-ignore
        await this.relayHubContract.calculateCharge(maxPossibleGas, {
            gasPrice: (_e = (_d = req.gasPrice) === null || _d === void 0 ? void 0 : _d.toString()) !== null && _e !== void 0 ? _e : '0',
            pctRelayFee: req.pctRelayFee.toString(),
            baseRelayFee: req.baseRelayFee.toString(),
            relayWorker: req.relayWorker,
            forwarder: req.forwarder,
            paymaster: req.paymaster,
            paymasterData: req.paymasterData,
            clientId: req.clientId
        });
        const paymasterBalance = await this.relayHubContract.balanceOf(req.paymaster);
        if (paymasterBalance.lt(maxCharge)) {
            throw new Error(`paymaster balance too low: ${paymasterBalance.toString()}, maxCharge: ${maxCharge.toString()}`);
        }
        console.log(`paymaster balance: ${paymasterBalance.toString()}, maxCharge: ${maxCharge.toString()}`);
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        console.log(`Estimated max charge of relayed tx: ${maxCharge.toString()}, GasLimit of relayed tx: ${maxPossibleGas}`);
        const { signedTx } = await this._sendTransaction({
            signer: this.getWorkerAddress(workerIndex),
            method,
            destination: req.relayHubAddress,
            gasLimit: maxPossibleGas.toString(),
            gasPrice: req.gasPrice
        });
        // after sending a transaction is a good time to check the worker's balance, and replenish it.
        await this.replenishWorker(workerIndex);
        return signedTx;
    }
    start() {
        debug('Polling new blocks');
        const handler = () => {
            this.contractInteractor.getBlock('latest')
                .then(block => {
                if (block.number > this.lastScannedBlock) {
                    this._workerSemaphore.bind(this)(block);
                }
            })
                .catch((e) => {
                this.emit('error', e);
                console.error('error in start:', e);
            });
        };
        this.workerTask = setInterval(handler, 10 * this.timeUnit());
    }
    stop() {
        clearInterval(this.workerTask);
        console.log('Successfully stopped polling!!');
    }
    _workerSemaphore(blockHeader) {
        if (this._workerSemaphoreOn) {
            debug('Different worker is not finished yet');
            return;
        }
        this._workerSemaphoreOn = true;
        this._worker(blockHeader)
            .then(() => {
            this._workerSemaphoreOn = false;
        })
            .catch((e) => {
            if (e instanceof StateError) {
                if (e.message !== this.lastError) {
                    this.lastError = e.message;
                    console.log('worker: ', this.lastError);
                }
            }
            else {
                this.emit('error', e);
                console.error('error in worker:', e);
            }
            this.ready = false;
            this._workerSemaphoreOn = false;
        });
    }
    fatal(message) {
        console.error('FATAL: ' + message);
        process.exit(1);
    }
    async _init() {
        await this.contractInteractor._init();
        this.relayHubContract = await this.contractInteractor._createRelayHub(this.hubAddress);
        const relayHubAddress = this.relayHubContract.address;
        console.log('Server address', this.managerAddress);
        const code = await this.contractInteractor.getCode(relayHubAddress);
        if (code.length < 10) {
            this.fatal(`No RelayHub deployed at address ${relayHubAddress}.`);
        }
        else {
            debug('code length', code.length);
        }
        const version = await this.relayHubContract.versionHub().catch(_ => 'no getVersion() method');
        if (!this.versionManager.isMinorSameOrNewer(version)) {
            this.fatal(`Not a valid RelayHub at ${relayHubAddress}: version: ${version}`);
        }
        const stakeManagerAddress = await this.relayHubContract.stakeManager();
        this.stakeManagerContract = await this.contractInteractor._createStakeManager(stakeManagerAddress);
        const stakeManagerTopics = [Object.keys(this.stakeManagerContract.contract.events).filter(x => (x.includes('0x')))];
        this.topics = stakeManagerTopics.concat([['0x' + '0'.repeat(24) + this.managerAddress.slice(2)]]);
        this.chainId = await this.contractInteractor.getChainId();
        this.networkId = await this.contractInteractor.getNetworkId();
        if (this.devMode && (this.chainId < 1000 || this.networkId < 1000)) {
            console.log('Don\'t use real network\'s chainId & networkId while in devMode.');
            process.exit(-1);
        }
        this.rawTxOptions = this.contractInteractor.getRawTxOptions();
        debug('initialized', this.chainId, this.networkId, this.rawTxOptions);
        this.initialized = true;
    }
    async replenishWorker(workerIndex) {
        var _a, _b, _c, _d;
        const receipts = [];
        const workerAddress = this.getWorkerAddress(workerIndex);
        const workerBalance = await this.getWorkerBalance(workerIndex);
        if (workerBalance.lt(web3_utils_1.toBN(this.workerMinBalance))) {
            const refill = web3_utils_1.toBN(this.workerTargetBalance).sub(workerBalance);
            const balance = await this.getManagerBalance();
            const managerHubBalance = (_b = await ((_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.balanceOf(this.managerAddress))) !== null && _b !== void 0 ? _b : web3_utils_1.toBN(0);
            console.log(`== replenishWorker(${workerIndex}): mgr balance=${balance.div(web3_utils_1.toBN(1e18)).toString()}  manager hub balance=${managerHubBalance.div(web3_utils_1.toBN(1e18)).toString()} 
          worker balance=${workerBalance.div(web3_utils_1.toBN(1e18)).toString()} refill=${refill.div(web3_utils_1.toBN(1e18)).toString()}`);
            if (refill.lt(managerHubBalance.sub(web3_utils_1.toBN(minimumRelayBalance)))) {
                const method = (_c = this.relayHubContract) === null || _c === void 0 ? void 0 : _c.contract.methods.withdraw(web3_utils_1.toHex(refill), workerAddress);
                receipts.push((await this._sendTransaction({
                    signer: this.getManagerAddress(),
                    destination: (_d = this.relayHubContract) === null || _d === void 0 ? void 0 : _d.address,
                    method
                })).receipt);
            }
            else if (refill.lt(balance.sub(web3_utils_1.toBN(minimumRelayBalance)))) {
                receipts.push((await this._sendTransaction({
                    signer: this.getManagerAddress(),
                    destination: workerAddress,
                    value: web3_utils_1.toHex(refill),
                    gasLimit: mintxgascost.toString()
                })).receipt);
            }
            else {
                const message = `== replenishWorker: can't replenish: mgr balance too low ${balance.div(web3_utils_1.toBN(1e18)).toString()} refill=${refill.div(web3_utils_1.toBN(1e18)).toString()}`;
                this.emit('fundingNeeded', message);
                console.log(message);
            }
        }
        return receipts;
    }
    async _worker(blockHeader) {
        if (!this.initialized) {
            await this._init();
        }
        const gasPriceString = await this.contractInteractor.getGasPrice();
        this.gasPrice = Math.floor(parseInt(gasPriceString) * this.gasPriceFactor);
        if (this.gasPrice === 0) {
            throw new StateError('Could not get gasPrice from node');
        }
        const balance = await this.getManagerBalance();
        if (balance.lt(web3_utils_1.toBN(minimumRelayBalance))) {
            throw new StateError(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Server's balance too low ( ${balance}, required ${minimumRelayBalance}). Waiting for funding...`);
        }
        let receipts = await this._handlePastEvents(blockHeader);
        await this._resendUnconfirmedTransactions(blockHeader);
        if (this.stake.eq(web3_utils_1.toBN(0))) {
            throw new StateError('Waiting for stake');
        }
        const registered = await this._isRegistered();
        if (!registered) {
            throw new StateError('Not registered yet...');
        }
        if (!this.authorizedHub) {
            this.emit('error', new Error('Hub not authorized...'));
            this.ready = false;
            return receipts;
        }
        const workerIndex = 0;
        receipts = receipts.concat(await this.replenishWorker(workerIndex));
        const workerBalance = await this.getWorkerBalance(workerIndex);
        if (workerBalance.lt(web3_utils_1.toBN(this.workerMinBalance))) {
            this.emit('error', new Error('workers not funded...'));
            this.ready = false;
            return receipts;
        }
        if (!this.ready) {
            console.log('Relay is Ready.');
        }
        this.ready = true;
        delete this.lastError;
        return receipts;
    }
    async getManagerBalance() {
        return web3_utils_1.toBN(await this.contractInteractor.getBalance(this.managerAddress));
    }
    async getWorkerBalance(workerIndex) {
        return web3_utils_1.toBN(await this.contractInteractor.getBalance(this.getWorkerAddress(workerIndex)));
    }
    async refreshStake() {
        var _a, _b, _c, _d;
        if (!this.initialized) {
            await this._init();
        }
        const stakeInfo = await ((_a = this.stakeManagerContract) === null || _a === void 0 ? void 0 : _a.getStakeInfo(this.managerAddress));
        this.stake = web3_utils_1.toBN((_b = stakeInfo === null || stakeInfo === void 0 ? void 0 : stakeInfo.stake) !== null && _b !== void 0 ? _b : '0');
        if (this.stake.eq(web3_utils_1.toBN(0))) {
            return this.stake;
        }
        // first time getting stake, setting owner
        if (this.owner == null) {
            this.owner = stakeInfo === null || stakeInfo === void 0 ? void 0 : stakeInfo.owner;
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            debug(`Got staked for the first time. Owner: ${this.owner}. Stake: ${this.stake.toString()}`);
        }
        this.unstakeDelay = web3_utils_1.toBN((_c = stakeInfo === null || stakeInfo === void 0 ? void 0 : stakeInfo.unstakeDelay) !== null && _c !== void 0 ? _c : '0');
        this.withdrawBlock = web3_utils_1.toBN((_d = stakeInfo === null || stakeInfo === void 0 ? void 0 : stakeInfo.withdrawBlock) !== null && _d !== void 0 ? _d : '0');
        return this.stake;
    }
    async _handlePastEvents(blockHeader) {
        var _a;
        const options = {
            fromBlock: this.lastScannedBlock + 1,
            toBlock: 'latest',
            address: (_a = this.stakeManagerContract) === null || _a === void 0 ? void 0 : _a.address,
            topics: this.topics
        };
        const logs = await this.contractInteractor.getPastLogs(options);
        spam('logs?', logs);
        spam('options? ', options);
        const decodedLogs = abi_decoder_1.default.decodeLogs(logs).map(this._parseEvent);
        spam('decodedLogs?', decodedLogs, this.lastScannedBlock);
        let receipts = [];
        // TODO: what about 'penalize' events? should send balance to owner, I assume
        // TODO TODO TODO 'StakeAdded' is not the event you want to cat upon if there was no 'HubAuthorized' event
        for (const dlog of decodedLogs) {
            switch (dlog.name) {
                case 'HubAuthorized':
                    receipts = receipts.concat(await this._handleHubAuthorizedEvent(dlog));
                    break;
                case 'StakeAdded':
                    receipts = receipts.concat(await this._handleStakedEvent(dlog));
                    break;
                case 'HubUnauthorized':
                    receipts = receipts.concat(await this._handleHubUnauthorizedEvent(dlog));
                    break;
                case 'StakeUnlocked':
                    receipts = receipts.concat(await this._handleUnstakedEvent(dlog));
                    break;
            }
        }
        this.lastScannedBlock = blockHeader.number;
        return receipts;
    }
    async _handleHubAuthorizedEvent(dlog) {
        var _a;
        if (dlog.name !== 'HubAuthorized' || dlog.args.relayManager.toLowerCase() !== this.managerAddress.toLowerCase()) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`PANIC: handling wrong event ${dlog.name} or wrong event relay ${dlog.args.relay}`);
        }
        if (dlog.args.relayHub.toLowerCase() === ((_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.address.toLowerCase())) {
            this.authorizedHub = true;
        }
        return await this._registerIfNeeded();
    }
    async _handleHubUnauthorizedEvent(dlog) {
        var _a;
        if (dlog.name !== 'HubUnauthorized' || dlog.args.relayManager.toLowerCase() !== this.managerAddress.toLowerCase()) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`PANIC: handling wrong event ${dlog.name} or wrong event relay ${dlog.args.relay}`);
        }
        if (dlog.args.relayHub.toLowerCase() === ((_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.address.toLowerCase())) {
            this.authorizedHub = false;
        }
        const gasPrice = await this.contractInteractor.getGasPrice();
        let receipts = [];
        receipts = receipts.concat(await this._sendWorkersEthBalancesToOwner(gasPrice)).concat(await this._sendManagerHubBalanceToOwner(gasPrice));
        return receipts;
    }
    async _handleStakedEvent(dlog) {
        // sanity checks
        if (dlog.name !== 'StakeAdded' || dlog.args.relayManager.toLowerCase() !== this.managerAddress.toLowerCase()) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`PANIC: handling wrong event ${dlog.name} or wrong event relay ${dlog.args.relay}`);
        }
        await this.refreshStake();
        return await this._registerIfNeeded();
    }
    async _registerIfNeeded() {
        var _a, _b, _c, _d, _e;
        let receipts = [];
        if (!this.authorizedHub || this.stake.eq(web3_utils_1.toBN(0))) {
            debug(`can't register yet: auth=${this.authorizedHub} stake=${this.stake.toString()}`);
            return receipts;
        }
        // add worker only if not already added
        const workersAdded = await this._areWorkersAdded();
        if (!workersAdded) {
            // register on chain
            const addRelayWorkerMethod = (_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.contract.methods.addRelayWorkers([this.getWorkerAddress(0)]);
            receipts = receipts.concat((await this._sendTransaction({
                signer: this.getManagerAddress(),
                method: addRelayWorkerMethod,
                destination: (_b = this.relayHubContract) === null || _b === void 0 ? void 0 : _b.address
            })).receipt);
        }
        const registered = await this._isRegistered();
        if (!registered) {
            const registerMethod = (_c = this.relayHubContract) === null || _c === void 0 ? void 0 : _c.contract.methods.registerRelayServer(this.baseRelayFee, this.pctRelayFee, this.url);
            receipts = receipts.concat((await this._sendTransaction({
                signer: this.getManagerAddress(),
                method: registerMethod,
                destination: (_d = this.relayHubContract) === null || _d === void 0 ? void 0 : _d.address
            })).receipt);
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            debug(`Relay ${this.managerAddress} registered on hub ${(_e = this.relayHubContract) === null || _e === void 0 ? void 0 : _e.address}. `);
        }
        return receipts;
    }
    async _isRegistered() {
        var _a;
        const relayRegisteredEvents = await ((_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.contract.getPastEvents('RelayServerRegistered', {
            fromBlock: 1,
            filter: { relayManager: this.managerAddress }
        }));
        return (relayRegisteredEvents.find((e) => e.returnValues.relayManager.toLowerCase() === this.managerAddress.toLowerCase() &&
            e.returnValues.baseRelayFee.toString() === this.baseRelayFee.toString() &&
            e.returnValues.pctRelayFee.toString() === this.pctRelayFee.toString() &&
            e.returnValues.relayUrl.toString() === this.url.toString()) != null);
    }
    async _areWorkersAdded() {
        var _a;
        const workersAddedEvents = await ((_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.contract.getPastEvents('RelayWorkersAdded', {
            fromBlock: 1,
            filter: { relayManager: this.managerAddress }
        }));
        return (workersAddedEvents.find((e) => e.returnValues.newRelayWorkers
            .map((a) => a.toLowerCase()).includes(this.getWorkerAddress(0).toLowerCase())) != null);
    }
    async _handleUnstakedEvent(dlog) {
        console.log('handle Unstaked event', dlog);
        // sanity checks
        if (dlog.name !== 'StakeUnlocked' || dlog.args.relayManager.toLowerCase() !== this.managerAddress.toLowerCase()) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`PANIC: handling wrong event ${dlog.name} or wrong event relay ${dlog.args.relay}`);
        }
        await this.refreshStake();
        let receipts = [];
        const gasPrice = await this.contractInteractor.getGasPrice();
        receipts = receipts.concat(await this._sendManagerHubBalanceToOwner(gasPrice));
        receipts = receipts.concat(await this._sendMangerEthBalanceToOwner(gasPrice));
        receipts = receipts.concat(await this._sendWorkersEthBalancesToOwner(gasPrice));
        this.emit('unstaked');
        return receipts;
    }
    async _sendMangerEthBalanceToOwner(gasPrice) {
        const receipts = [];
        const gasLimit = mintxgascost;
        const txCost = web3_utils_1.toBN(gasLimit * parseInt(gasPrice));
        const managerBalance = await this.getManagerBalance();
        // sending manager eth balance to owner
        if (managerBalance.gte(txCost)) {
            console.log(`Sending manager eth balance ${managerBalance.toString()} to owner`);
            receipts.push((await this._sendTransaction({
                signer: this.getManagerAddress(),
                destination: this.owner,
                gasLimit: gasLimit.toString(),
                gasPrice,
                value: web3_utils_1.toHex(managerBalance.sub(txCost))
            })).receipt);
        }
        else {
            console.log(`manager balance too low: ${managerBalance.toString()}, tx cost: ${gasLimit * parseInt(gasPrice)}`);
        }
        return receipts;
    }
    async _sendWorkersEthBalancesToOwner(gasPrice) {
        // sending workers' balance to owner (currently one worker, todo: extend to multiple)
        const receipts = [];
        const gasLimit = mintxgascost;
        const txCost = web3_utils_1.toBN(gasLimit * parseInt(gasPrice));
        const workerIndex = 0;
        const workerBalance = await this.getWorkerBalance(workerIndex);
        if (workerBalance.gte(txCost)) {
            console.log(`Sending workers' eth balance ${workerBalance.toString()} to owner`);
            receipts.push((await this._sendTransaction({
                signer: this.getWorkerAddress(workerIndex),
                destination: this.owner,
                gasLimit: gasLimit.toString(),
                gasPrice,
                value: web3_utils_1.toHex(workerBalance.sub(txCost))
            })).receipt);
        }
        else {
            console.log(`balance too low: ${workerBalance.toString()}, tx cost: ${gasLimit * parseInt(gasPrice)}`);
        }
        return receipts;
    }
    async _sendManagerHubBalanceToOwner(gasPrice) {
        var _a, _b, _c, _d;
        const receipts = [];
        const managerHubBalance = (_b = await ((_a = this.relayHubContract) === null || _a === void 0 ? void 0 : _a.balanceOf(this.managerAddress))) !== null && _b !== void 0 ? _b : web3_utils_1.toBN(0);
        const method = (_c = this.relayHubContract) === null || _c === void 0 ? void 0 : _c.contract.methods.withdraw(web3_utils_1.toHex(managerHubBalance), this.owner);
        const withdrawTxGasLimit = await method.estimateGas({ from: this.getManagerAddress() });
        const withdrawTxCost = web3_utils_1.toBN(withdrawTxGasLimit * parseInt(gasPrice));
        if (managerHubBalance.gte(withdrawTxCost)) {
            console.log(`Sending manager hub balance ${managerHubBalance.toString()} to owner`);
            receipts.push((await this._sendTransaction({
                signer: this.getManagerAddress(),
                destination: (_d = this.relayHubContract) === null || _d === void 0 ? void 0 : _d.address,
                method
            })).receipt);
        }
        else {
            console.log(`manager hub balance too low: ${managerHubBalance.toString()}, tx cost: ${withdrawTxCost.toString()}`);
        }
        return receipts;
    }
    /**
     * resend Txs of all signers (manager, workers)
     * @return the receipt from the first request
     */
    async _resendUnconfirmedTransactions(blockHeader) {
        // repeat separately for each signer (manager, all workers)
        let signedTx = await this._resendUnconfirmedTransactionsForManager(blockHeader);
        if (signedTx != null) {
            return signedTx;
        }
        for (const workerIndex of [0]) {
            signedTx = await this._resendUnconfirmedTransactionsForWorker(blockHeader, workerIndex);
            if (signedTx != null) {
                return signedTx; // TODO: should we early-return ?
            }
        }
    }
    async _resendUnconfirmedTransactionsForManager(blockHeader) {
        const signer = this.getManagerAddress();
        return await this._resendUnconfirmedTransactionsForSigner(blockHeader, signer);
    }
    async _resendUnconfirmedTransactionsForWorker(blockHeader, workerIndex) {
        const signer = this.getWorkerAddress(workerIndex);
        return await this._resendUnconfirmedTransactionsForSigner(blockHeader, signer);
    }
    async _resendUnconfirmedTransactionsForSigner(blockHeader, signer) {
        // Load unconfirmed transactions from store, and bail if there are none
        let sortedTxs = await this.txStoreManager.getAllBySigner(signer);
        if (sortedTxs.length === 0) {
            return null;
        }
        debug('resending unconfirmed transactions');
        // Get nonce at confirmationsNeeded blocks ago
        for (const transaction of sortedTxs) {
            const receipt = await this.contractInteractor.getTransaction(transaction.txId);
            if (receipt == null) {
                // I believe this means this transaction was not confirmed
                continue;
            }
            if (receipt.blockNumber == null) {
                // eslint-disable-next-line @typescript-eslint/no-base-to-string
                throw new Error(`invalid block number in receipt ${receipt.toString()}`);
            }
            const txBlockNumber = receipt.blockNumber;
            const confirmations = blockHeader.number - txBlockNumber;
            if (confirmations >= confirmationsNeeded) {
                // Clear out all confirmed transactions (ie txs with nonce less than the account nonce at confirmationsNeeded blocks ago)
                debug(`removing tx number ${receipt.nonce} sent by ${receipt.from} with ${confirmations} confirmations`);
                await this.txStoreManager.removeTxsUntilNonce(receipt.from, receipt.nonce);
            }
        }
        // Load unconfirmed transactions from store again
        sortedTxs = await this.txStoreManager.getAllBySigner(signer);
        if (sortedTxs.length === 0) {
            return null;
        }
        // Check if the tx was mined by comparing its nonce against the latest one
        const nonce = await this.contractInteractor.getTransactionCount(signer);
        if (sortedTxs[0].nonce < nonce) {
            debug('resend', signer, ': awaiting confirmations for next mined transaction', nonce, sortedTxs[0].nonce, sortedTxs[0].txId);
            return null;
        }
        // If the tx is still pending, check how long ago we sent it, and resend it if needed
        if (Date.now() - (new Date(sortedTxs[0].createdAt)).getTime() < pendingTransactionTimeout) {
            spam(Date.now(), (new Date()), (new Date()).getTime());
            spam(sortedTxs[0].createdAt, (new Date(sortedTxs[0].createdAt)), (new Date(sortedTxs[0].createdAt)).getTime());
            debug('resend', signer, ': awaiting transaction', sortedTxs[0].txId, 'to be mined. nonce:', nonce);
            return null;
        }
        const { receipt, signedTx } = await this._resendTransaction(sortedTxs[0]);
        debug('resent transaction', sortedTxs[0].nonce, sortedTxs[0].txId, 'as', receipt.transactionHash);
        if (sortedTxs[0].attempts > 2) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            debug(`resend ${signer}: Sent tx ${sortedTxs[0].attempts} times already`);
        }
        return signedTx;
    }
    // signerIndex is the index into addresses array. zero is relayManager, the rest are workers
    async _sendTransaction({ signer, method, destination, value = '0x', gasLimit, gasPrice }) {
        var _a;
        const encodedCall = (_a = method === null || method === void 0 ? void 0 : method.encodeABI()) !== null && _a !== void 0 ? _a : '0x';
        const _gasPrice = parseInt(gasPrice !== null && gasPrice !== void 0 ? gasPrice : await this.contractInteractor.getGasPrice());
        debug('gasPrice', _gasPrice);
        debug('encodedCall', encodedCall);
        const gas = parseInt(gasLimit !== null && gasLimit !== void 0 ? gasLimit : await (method === null || method === void 0 ? void 0 : method.estimateGas({ from: signer })));
        debug('gasLimit', gas);
        debug('nonceMutex locked?', this.nonceMutex.isLocked());
        const releaseMutex = await this.nonceMutex.acquire();
        let signedTx;
        let storedTx;
        try {
            const nonce = await this._pollNonce(signer);
            debug('nonce', nonce);
            const txToSign = new ethereumjs_tx_1.Transaction({
                to: destination,
                value: value,
                gasLimit: gas,
                gasPrice: _gasPrice,
                data: Buffer.from(encodedCall.slice(2), 'hex'),
                nonce
            }, this.rawTxOptions);
            spam('txToSign', txToSign);
            const keyManager = this.managerKeyManager.isSigner(signer) ? this.managerKeyManager : this.workersKeyManager;
            signedTx = keyManager.signTransaction(signer, txToSign);
            storedTx = TxStoreManager_1.transactionToStoredTx(txToSign, signer, this.chainId, 1);
            this.nonces[signer]++;
            await this.txStoreManager.putTx(storedTx, false);
        }
        finally {
            releaseMutex();
        }
        const receipt = await this.contractInteractor.sendSignedTransaction(signedTx);
        debug('\ntxhash is', receipt.transactionHash);
        if (receipt.transactionHash.toLowerCase() !== storedTx.txId.toLowerCase()) {
            throw new Error(`txhash mismatch: from receipt: ${receipt.transactionHash} from txstore:${storedTx.txId}`);
        }
        return {
            receipt,
            signedTx
        };
    }
    async _resendTransaction(tx) {
        // Calculate new gas price as a % increase over the previous one
        let newGasPrice = tx.gasPrice * retryGasPriceFactor;
        // Sanity check to ensure we are not burning all our balance in gas fees
        if (newGasPrice > maxGasPrice) {
            debug('Capping gas price to max value of', maxGasPrice);
            newGasPrice = maxGasPrice;
        }
        // Resend transaction with exactly the same values except for gas price
        const txToSign = new ethereumjs_tx_1.Transaction({
            to: tx.to,
            gasLimit: tx.gas,
            gasPrice: newGasPrice,
            data: tx.data,
            nonce: tx.nonce
        }, this.rawTxOptions);
        debug('txToSign', txToSign);
        const keyManager = this.managerKeyManager.isSigner(tx.from) ? this.managerKeyManager : this.workersKeyManager;
        const signedTx = keyManager.signTransaction(tx.from, txToSign);
        const storedTx = TxStoreManager_1.transactionToStoredTx(txToSign, tx.from, this.chainId, tx.attempts + 1);
        await this.txStoreManager.putTx(storedTx, true);
        debug('resending tx with nonce', txToSign.nonce, 'from', tx.from);
        debug('account nonce', await this.contractInteractor.getTransactionCount(tx.from));
        const receipt = await this.contractInteractor.sendSignedTransaction(signedTx);
        debug('\ntxhash is', receipt.transactionHash);
        if (receipt.transactionHash.toLowerCase() !== storedTx.txId.toLowerCase()) {
            throw new Error(`txhash mismatch: from receipt: ${receipt.transactionHash} from txstore:${storedTx.txId}`);
        }
        return {
            receipt,
            signedTx
        };
    }
    async _pollNonce(signer) {
        const nonce = await this.contractInteractor.getTransactionCount(signer, 'pending');
        if (nonce > this.nonces[signer]) {
            debug('NONCE FIX for signer=', signer, ': nonce=', nonce, this.nonces[signer]);
            this.nonces[signer] = nonce;
        }
        return nonce;
    }
    _parseEvent(event) {
        if ((event === null || event === void 0 ? void 0 : event.events) === undefined) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            return `not event: ${event === null || event === void 0 ? void 0 : event.toString()}`;
        }
        const args = {};
        // event arguments is for some weird reason give as ".events"
        for (const eventArgument of event.events) {
            args[eventArgument.name] = eventArgument.value;
        }
        return {
            name: event.name,
            address: event.address,
            args: args
        };
    }
    timeUnit() {
        if (this.devMode) {
            return 10;
        }
        return 1000;
    }
}
exports.RelayServer = RelayServer;
//# sourceMappingURL=RelayServer.js.map