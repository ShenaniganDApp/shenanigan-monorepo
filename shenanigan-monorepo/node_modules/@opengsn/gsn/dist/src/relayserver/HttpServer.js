"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const jsonrpc_lite_1 = __importDefault(require("jsonrpc-lite"));
const body_parser_1 = __importDefault(require("body-parser"));
const cors_1 = __importDefault(require("cors"));
class HttpServer {
    constructor(port, backend) {
        this.port = port;
        this.backend = backend;
        this.app = express_1.default();
        this.app.use(cors_1.default());
        this.app.use(body_parser_1.default.urlencoded({ extended: false }));
        this.app.use(body_parser_1.default.json());
        console.log('setting handlers');
        this.app.post('/', this.rootHandler.bind(this));
        // TODO change all to jsonrpc
        this.app.post('/getaddr', this.pingHandler.bind(this));
        this.app.get('/getaddr', this.pingHandler.bind(this));
        this.app.post('/relay', this.relayHandler.bind(this));
        this.backend.once('removed', this.stop.bind(this));
        this.backend.once('unstaked', this.close.bind(this));
        this.backend.on('error', (e) => { console.error('httpServer:', e); });
    }
    start() {
        if (this.serverInstance === undefined) {
            this.serverInstance = this.app.listen(this.port, () => {
                console.log('Listening on port', this.port);
            });
        }
        try {
            this.backend.start();
            console.log('Relay worker started.');
        }
        catch (e) {
            console.log('relay task error', e);
        }
    }
    stop() {
        var _a;
        (_a = this.serverInstance) === null || _a === void 0 ? void 0 : _a.close();
        console.log('Http server stopped.\nShutting down relay...');
    }
    close() {
        console.log('Stopping relay worker...');
        this.backend.stop();
    }
    // TODO: use this when changing to jsonrpc
    async rootHandler(req, res) {
        var _a;
        let status;
        try {
            let res;
            // @ts-ignore
            const func = this.backend[req.body.method];
            if (func != null) {
                res = (_a = await func.apply(this.backend, [req.body.params])) !== null && _a !== void 0 ? _a : { code: 200 };
            }
            else {
                // @ts-ignore
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw Error(`Implementation of method ${req.body.params} not found on backend!`);
            }
            status = jsonrpc_lite_1.default.success(req.body.id, res);
        }
        catch (e) {
            let stack = e.stack.toString();
            // remove anything after 'rootHandler'
            stack = stack.replace(/(rootHandler.*)[\s\S]*/, '$1');
            status = jsonrpc_lite_1.default.error(req.body.id, new jsonrpc_lite_1.default.JsonRpcError(stack, -125));
        }
        res.send(status);
    }
    pingHandler(req, res) {
        const pingResponse = this.backend.pingHandler();
        res.send(pingResponse);
        console.log(`address ${pingResponse.RelayServerAddress} sent. ready: ${pingResponse.Ready}`);
    }
    async relayHandler(req, res) {
        if (!this.backend.isReady()) {
            res.send('Error: relay not ready');
            return;
        }
        try {
            const signedTx = await this.backend.createRelayTransaction(req.body);
            res.send({ signedTx });
        }
        catch (e) {
            res.send({ error: e.message });
            console.log('tx failed:', e);
        }
    }
}
exports.HttpServer = HttpServer;
//# sourceMappingURL=HttpServer.js.map