"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethUtils = __importStar(require("ethereumjs-util"));
const ow_1 = __importDefault(require("ow"));
const ethereumjs_tx_1 = require("ethereumjs-tx");
const nedb_async_1 = __importDefault(require("nedb-async"));
class StoredTx {
    constructor(params) {
        // Object.keys(tx).forEach(key => {
        //   this[key] = ethUtils.bufferToHex(tx[key])
        // })
        this.from = ethUtils.bufferToHex(params.from);
        this.to = ethUtils.bufferToHex(params.to);
        this.gas = ethUtils.bufferToInt(params.gas);
        this.gasPrice = ethUtils.bufferToInt(params.gasPrice);
        this.data = ethUtils.bufferToHex(params.data);
        this.nonce = ethUtils.bufferToInt(params.nonce);
        this.txId = params.txId;
        this.attempts = params.attempts;
    }
}
exports.StoredTx = StoredTx;
function transactionToStoredTx(tx, from, chainId, attempts) {
    return {
        from,
        to: ethUtils.bufferToHex(tx.to),
        gas: ethUtils.bufferToInt(tx.gasLimit),
        gasPrice: ethUtils.bufferToInt(tx.gasPrice),
        data: ethUtils.bufferToHex(tx.data),
        nonce: ethUtils.bufferToInt(tx.nonce),
        txId: ethUtils.bufferToHex(tx.hash()),
        attempts: attempts
    };
}
exports.transactionToStoredTx = transactionToStoredTx;
function storedTxToTransaction(stx) {
    return new ethereumjs_tx_1.Transaction({
        to: stx.to,
        gasLimit: stx.gas,
        gasPrice: stx.gasPrice,
        nonce: stx.nonce,
        data: stx.data
    });
}
exports.storedTxToTransaction = storedTxToTransaction;
exports.TXSTORE_FILENAME = 'txstore.db';
class TxStoreManager {
    constructor({ workdir = '/tmp/test/', inMemory = false }) {
        this.txstore = new nedb_async_1.default({
            filename: inMemory ? undefined : `${workdir}/${exports.TXSTORE_FILENAME}`,
            autoload: true,
            timestampData: true
        });
        this.txstore.ensureIndex({ fieldName: 'txId', unique: true });
        this.txstore.ensureIndex({ fieldName: 'nonceSigner', unique: true });
        console.log('txstore created in ', inMemory ? 'memory' : `${workdir}/${exports.TXSTORE_FILENAME}`);
    }
    async putTx(tx, updateExisting = false) {
        // eslint-disable-next-line
        if (!tx || !tx.txId || !tx.attempts || tx.nonce === undefined) {
            throw new Error('Invalid tx:' + JSON.stringify(tx));
        }
        const tx1 = Object.assign(Object.assign({}, tx), { txId: tx.txId.toLowerCase(), nonceSigner: {
                nonce: tx.nonce,
                signer: tx.from.toLowerCase()
            } });
        const existing = await this.txstore.asyncFindOne({ nonceSigner: tx1.nonceSigner });
        // eslint-disable-next-line
        if (existing && updateExisting) {
            await this.txstore.asyncUpdate({ txId: existing.txId }, { $set: tx1 });
        }
        else {
            await this.txstore.asyncInsert(tx1);
        }
    }
    async getTxByNonce(signer, nonce) {
        ow_1.default(nonce, ow_1.default.any(ow_1.default.number, ow_1.default.string));
        ow_1.default(signer, ow_1.default.string);
        return await this.txstore.asyncFindOne({
            nonceSigner: {
                signer: signer.toLowerCase(),
                nonce
            }
        }, { _id: 0 });
    }
    async getTxById(txId) {
        ow_1.default(txId, ow_1.default.string);
        return await this.txstore.asyncFindOne({ txId: txId.toLowerCase() }, { _id: 0 });
    }
    async removeTxByNonce(signer, nonce) {
        ow_1.default(nonce, ow_1.default.any(ow_1.default.string, ow_1.default.number));
        ow_1.default(signer, ow_1.default.string);
        return await this.txstore.asyncRemove({
            $and: [
                { 'nonceSigner.nonce': nonce },
                { 'nonceSigner.signer': signer.toLowerCase() }
            ]
        }, { multi: true });
    }
    async removeTxsUntilNonce(signer, nonce) {
        ow_1.default(nonce, ow_1.default.number);
        ow_1.default(signer, ow_1.default.string);
        return await this.txstore.asyncRemove({
            $and: [
                { 'nonceSigner.nonce': { $lte: nonce } },
                { 'nonceSigner.signer': signer.toLowerCase() }
            ]
        }, { multi: true });
    }
    async clearAll() {
        await this.txstore.asyncRemove({}, { multi: true });
    }
    async getAllBySigner(signer) {
        return (await this.txstore.asyncFind({ 'nonceSigner.signer': signer.toLowerCase() })).sort(function (tx1, tx2) {
            return tx1.nonce - tx2.nonce;
        });
    }
    async getAll() {
        return (await this.txstore.asyncFind({})).sort(function (tx1, tx2) {
            return tx1.nonce - tx2.nonce;
        });
    }
}
exports.TxStoreManager = TxStoreManager;
//# sourceMappingURL=TxStoreManager.js.map