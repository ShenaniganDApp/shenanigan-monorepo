"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = __importDefault(require("ethereumjs-util"));
const web3_utils_1 = __importStar(require("web3-utils"));
const web3_eth_abi_1 = __importDefault(require("web3-eth-abi"));
const bn_js_1 = __importDefault(require("bn.js"));
function removeHexPrefix(hex) {
    if (hex == null || typeof hex.replace !== 'function') {
        throw new Error('Cannot remove hex prefix');
    }
    return hex.replace(/^0x/, '');
}
exports.removeHexPrefix = removeHexPrefix;
const zeroPad = '0000000000000000000000000000000000000000000000000000000000000000';
function padTo64(hex) {
    if (hex.length < 64) {
        hex = (zeroPad + hex).slice(-64);
    }
    return hex;
}
exports.padTo64 = padTo64;
function event2topic(contract, names) {
    // for testing: don't crash on mockup..
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (!contract.options || !contract.options.jsonInterface) {
        return names;
    }
    if (typeof names === 'string') {
        return event2topic(contract, [names])[0];
    }
    return contract.options.jsonInterface
        .filter((e) => names.includes(e.name))
        // @ts-ignore
        .map(web3_eth_abi_1.default.encodeEventSignature);
}
exports.event2topic = event2topic;
async function getEip712Signature(web3, typedRequestData, methodSuffix = '', jsonStringifyRequest = false) {
    const senderAddress = typedRequestData.message.from;
    let dataToSign;
    if (jsonStringifyRequest) {
        dataToSign = JSON.stringify(typedRequestData);
    }
    else {
        dataToSign = typedRequestData;
    }
    return await new Promise((resolve, reject) => {
        let method;
        // @ts-ignore (the entire web3 typing is fucked up)
        if (typeof web3.currentProvider.sendAsync === 'function') {
            // @ts-ignore
            method = web3.currentProvider.sendAsync;
        }
        else {
            // @ts-ignore
            method = web3.currentProvider.send;
        }
        method.bind(web3.currentProvider)({
            method: 'eth_signTypedData' + methodSuffix,
            params: [senderAddress, dataToSign],
            from: senderAddress,
            id: Date.now()
        }, (error, result) => {
            if (error != null || result == null) {
                reject(error);
            }
            else {
                resolve(result.result);
            }
        });
    });
}
exports.getEip712Signature = getEip712Signature;
/**
 * @returns maximum possible gas consumption by this relayed call
 */
function calculateTransactionMaxPossibleGas({ gasLimits, hubOverhead, relayCallGasLimit }) {
    return hubOverhead +
        parseInt(relayCallGasLimit) +
        parseInt(gasLimits.acceptRelayedCallGasLimit) +
        parseInt(gasLimits.preRelayedCallGasLimit) +
        parseInt(gasLimits.postRelayedCallGasLimit);
}
exports.calculateTransactionMaxPossibleGas = calculateTransactionMaxPossibleGas;
function getEcRecoverMeta(message, signature) {
    if (typeof signature === 'string') {
        const r = parseHexString(signature.substr(2, 65));
        const s = parseHexString(signature.substr(66, 65));
        const v = parseHexString(signature.substr(130, 2));
        signature = {
            v: v,
            r: r,
            s: s
        };
    }
    const msg = Buffer.concat([Buffer.from('\x19Ethereum Signed Message:\n32'), Buffer.from(removeHexPrefix(message), 'hex')]);
    const signed = web3_utils_1.default.sha3('0x' + msg.toString('hex'));
    if (signed == null) {
        throw new Error('web3Utils.sha3 failed somehow');
    }
    const bufSigned = Buffer.from(removeHexPrefix(signed), 'hex');
    const recoveredPubKey = ethereumjs_util_1.default.ecrecover(bufSigned, signature.v[0], Buffer.from(signature.r), Buffer.from(signature.s));
    return ethereumjs_util_1.default.bufferToHex(ethereumjs_util_1.default.pubToAddress(recoveredPubKey));
}
exports.getEcRecoverMeta = getEcRecoverMeta;
function parseHexString(str) {
    var result = [];
    while (str.length >= 2) {
        result.push(parseInt(str.substring(0, 2), 16));
        str = str.substring(2, str.length);
    }
    return result;
}
exports.parseHexString = parseHexString;
function isSameAddress(address1, address2) {
    return address1.toLowerCase() === address2.toLowerCase();
}
exports.isSameAddress = isSameAddress;
async function sleep(ms) {
    return await new Promise(resolve => setTimeout(resolve, ms));
}
exports.sleep = sleep;
function ether(n) {
    return new bn_js_1.default(web3_utils_1.toWei(n, 'ether'));
}
exports.ether = ether;
//# sourceMappingURL=Utils.js.map