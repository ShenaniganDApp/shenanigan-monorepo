"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const config_1 = require("./config");
const imports_fs_1 = require("@resolver-engine/imports-fs");
const imports_1 = require("@resolver-engine/imports");
const findInputs_1 = require("./findInputs");
const utils_1 = require("./utils");
async function flattenProject(configPath) {
    await flattenAndSave(await config_1.loadConfig(configPath));
}
exports.flattenProject = flattenProject;
async function flattenAndSave(input) {
    const config = config_1.inputToConfig(input);
    const output = await getContractDependency(config);
    await saveToFile(output, config);
}
exports.flattenAndSave = flattenAndSave;
async function getContractDependency(config) {
    const resolver = imports_fs_1.ImportsFsEngine().addResolver(imports_fs_1.resolvers.BacktrackFsResolver(config.nodeModulesDirectory));
    const allContracts = findInputs_1.findInputs(config.sourceDirectory, utils_1.getExtensionForCompilerType(config));
    return Promise.all(allContracts.map(async (contract) => imports_1.gatherSourcesAndCanonizeImports([contract], '.', resolver)));
}
const fsOps = {
    createDirectory: mkdirp_1.default.sync,
    writeFile: fs_1.default.writeFileSync
};
const unique = (arr) => [...new Set(arr)];
function saveToFile(output, config, fileSystem = fsOps) {
    const outputDirectory = config.flattenOutputDirectory;
    fileSystem.createDirectory(outputDirectory);
    output.map((contract) => {
        const rootContract = contract[contract.length - 1];
        const fileName = path_1.default.parse(rootContract.url).base;
        const filePath = path_1.default.join(outputDirectory, fileName);
        const contractsWithCommentedDirectives = contract.map(replaceDirectivesWithComments(rootContract));
        const source = ''.concat(...unique(contractsWithCommentedDirectives));
        fileSystem.writeFile(filePath, source);
    });
}
function replaceDirectivesWithComments(rootContract) {
    const IMPORT_SOLIDITY_REGEX = /import/gi;
    const IMPORT_NODE_MODULES_REGEX = /(import.*").*node_modules\/(.*\n)/gi;
    const PRAGMA_SOLIDITY_REGEX = /pragma solidity/gi;
    const NODE_MODULES_REGEX = /^.*\/node_modules\//gi;
    return (dependency) => {
        const sourceWithImportsWithRelativeImports = dependency.source.replace(IMPORT_NODE_MODULES_REGEX, '$1$2');
        const sourceWithCommentedImports = sourceWithImportsWithRelativeImports.replace(IMPORT_SOLIDITY_REGEX, '// import');
        const filePath = dependency.url.replace(NODE_MODULES_REGEX, '');
        if (dependency === rootContract) {
            return `// Root file: ${filePath}\n\n` + sourceWithCommentedImports;
        }
        const sourceWithCommentedPragmas = sourceWithCommentedImports.replace(PRAGMA_SOLIDITY_REGEX, '// pragma solidity');
        return `// Dependency file: ${filePath}\n\n` + sourceWithCommentedPragmas + '\n\n';
    };
}
