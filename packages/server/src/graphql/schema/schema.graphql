input AddOptionsInput {
  options: [String!]!
  challengeId: String!
  clientMutationId: String
}

type AddOptionsPayload {
  options: [String]
  error: String
  clientMutationId: String
}

"""Challenge data"""
type Challenge implements Node {
  """The ID of an object"""
  id: ID!

  """mongoose _id"""
  _id: String!
  address: String!
  title: String!
  content: String
  active: Boolean!
  series: Int!
  donations(after: String, first: Int, before: String, last: Int): DonationConnection
  creator: User!
  options: [String]!
  predictions(after: String, first: Int, before: String, last: Int): PredictionConnection
  comments(after: String, first: Int, before: String, last: Int): CommentConnection
  challengeCards(after: String, first: Int, before: String, last: Int): ChallengeCardConnection
}

"""ChallengeCard data"""
type ChallengeCard implements Node {
  """The ID of an object"""
  id: ID!

  """mongoose _id"""
  _id: String!
  title: String!
  content: String
  address: String!
  ipfs: String!
  streamUrl: String!
  price: Float!
  result: Int!
  totalMint: Int!
  creator: User!
  challenge: Challenge!
}

"""A connection to a list of items."""
type ChallengeCardConnection {
  """Number of items in this connection"""
  count: Int!

  """
  A count of the total number of objects in this connection, ignoring pagination.
      This allows a client to fetch the first five objects by passing "5" as the
      argument to "first", then fetch the total count so it could display "5 of 83",
      for example.
  """
  totalCount: Int!

  """Offset from start"""
  startCursorOffset: Int!

  """Offset till end"""
  endCursorOffset: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfoExtended!

  """A list of edges."""
  edges: [ChallengeCardEdge]!
}

"""An edge in a connection."""
type ChallengeCardEdge {
  """The item at the end of the edge"""
  node: ChallengeCard

  """A cursor for use in pagination"""
  cursor: String!
}

"""A connection to a list of items."""
type ChallengeConnection {
  """Number of items in this connection"""
  count: Int!

  """
  A count of the total number of objects in this connection, ignoring pagination.
      This allows a client to fetch the first five objects by passing "5" as the
      argument to "first", then fetch the total count so it could display "5 of 83",
      for example.
  """
  totalCount: Int!

  """Offset from start"""
  startCursorOffset: Int!

  """Offset till end"""
  endCursorOffset: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfoExtended!

  """A list of edges."""
  edges: [ChallengeEdge]!
}

"""An edge in a connection."""
type ChallengeEdge {
  """The item at the end of the edge"""
  node: Challenge

  """A cursor for use in pagination"""
  cursor: String!
}

"""Comment data"""
type Comment implements Node {
  """The ID of an object"""
  id: ID!
  _id: ID!
  challenge: Challenge
  challengeSeries: Int!
  content: String!
  creator: User!
}

input CommentAddedInput {
  clientSubscriptionId: String
}

type CommentAddedPayload {
  comment: Comment!
  clientSubscriptionId: String
}

"""A connection to a list of items."""
type CommentConnection {
  """Number of items in this connection"""
  count: Int!

  """
  A count of the total number of objects in this connection, ignoring pagination.
      This allows a client to fetch the first five objects by passing "5" as the
      argument to "first", then fetch the total count so it could display "5 of 83",
      for example.
  """
  totalCount: Int!

  """Offset from start"""
  startCursorOffset: Int!

  """Offset till end"""
  endCursorOffset: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfoExtended!

  """A list of edges."""
  edges: [CommentEdge]!
}

"""An edge in a connection."""
type CommentEdge {
  """The item at the end of the edge"""
  node: Comment

  """A cursor for use in pagination"""
  cursor: String!
}

input CreateChallengeCardInput {
  title: String!
  content: String
  address: String!
  ipfs: String!
  streamUrl: String!
  price: Float!
  result: Int!
  totalMint: Int!
  challengeId: String!
  clientMutationId: String
}

type CreateChallengeCardPayload {
  _id: String!
  title: String
  content: String
  ipfs: [String]
  streamUrl: [String]
  result: [Int]
  price: [Float]
  totalMint: [Int]
  error: String
  clientMutationId: String
}

input CreateChallengeInput {
  address: String!
  title: String!
  content: String!
  options: [String]!
  clientMutationId: String
}

type CreateChallengePayload {
  _id: String!
  title: String
  content: String
  options: [String]
  error: String
  clientMutationId: String
}

input CreateCommentInput {
  content: String!
  challengeId: String!
  clientMutationId: String
}

type CreateCommentPayload {
  _id: ID!
  challengeSeries: Int!
  content: String!
  creator: ID!
  error: String
  clientMutationId: String
}

input CreateDonationInput {
  amount: Float!
  content: String
  challenge: String!
  receiver: String!
  clientMutationId: String
}

type CreateDonationPayload {
  amount: Float
  receiver: String
  challengeSeries: String
  error: String
  clientMutationId: String
}

input CreatePredictionInput {
  cards: [String]!
  option: Int!
  opponentId: String
  challengeId: String!
  content: String
  blockTimestamp: Int!
  clientMutationId: String
}

type CreatePredictionPayload {
  cards: [String]
  option: Int
  opponent: String
  error: String
  clientMutationId: String
}

input DeleteChallengeCardInput {
  cardId: String!
  clientMutationId: String
}

type DeleteChallengeCardPayload {
  error: String
  clientMutationId: String
}

input DeleteChallengeInput {
  challengeId: String!
  clientMutationId: String
}

type DeleteChallengePayload {
  error: String
  clientMutationId: String
}

input DeleteInput {
  _id: String!
  clientMutationId: String
}

type DeletePayload {
  message: String
  error: String
  clientMutationId: String
}

"""Donation data"""
type Donation implements Node {
  """The ID of an object"""
  id: ID!
  _id: ID!
  amount: Float!
  creator: User!
  comment: Comment
  challengeSeries: Int!
  challenge: Challenge
  receiver: User
}

"""A connection to a list of items."""
type DonationConnection {
  """Number of items in this connection"""
  count: Int!

  """
  A count of the total number of objects in this connection, ignoring pagination.
      This allows a client to fetch the first five objects by passing "5" as the
      argument to "first", then fetch the total count so it could display "5 of 83",
      for example.
  """
  totalCount: Int!

  """Offset from start"""
  startCursorOffset: Int!

  """Offset till end"""
  endCursorOffset: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfoExtended!

  """A list of edges."""
  edges: [DonationEdge]!
}

"""An edge in a connection."""
type DonationEdge {
  """The item at the end of the edge"""
  node: Donation

  """A cursor for use in pagination"""
  cursor: String!
}

input GetOrCreateUserInput {
  username: String
  address: String!
  burner: Boolean!
  clientMutationId: String
}

type GetOrCreateUserPayload {
  user: User
  error: String
  clientMutationId: String
}

type Mutation {
  DeleteUser(input: DeleteInput!): DeletePayload
  GetOrCreateUser(input: GetOrCreateUserInput!): GetOrCreateUserPayload
  AddOptions(input: AddOptionsInput!): AddOptionsPayload
  CreateChallenge(input: CreateChallengeInput!): CreateChallengePayload
  DeleteChallenge(input: DeleteChallengeInput!): DeleteChallengePayload
  ToggleActive(input: ToggleActiveInput!): ToggleActivePayload
  CreatePrediction(input: CreatePredictionInput!): CreatePredictionPayload
  CreateComment(input: CreateCommentInput!): CreateCommentPayload
  CreateDonation(input: CreateDonationInput!): CreateDonationPayload
  CreateChallengeCard(input: CreateChallengeCardInput!): CreateChallengeCardPayload
  DeleteChallengeCard(input: DeleteChallengeCardInput!): DeleteChallengeCardPayload
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfoExtended {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""Prediction data"""
type Prediction implements Node {
  """The ID of an object"""
  id: ID!
  _id: ID!
  cards: [String]!
  option: Int!
  opponent: Prediction
  challenge: Challenge
  creator: User
  comment: Comment
  blockTimestamp: Int!
}

"""A connection to a list of items."""
type PredictionConnection {
  """Number of items in this connection"""
  count: Int!

  """
  A count of the total number of objects in this connection, ignoring pagination.
      This allows a client to fetch the first five objects by passing "5" as the
      argument to "first", then fetch the total count so it could display "5 of 83",
      for example.
  """
  totalCount: Int!

  """Offset from start"""
  startCursorOffset: Int!

  """Offset till end"""
  endCursorOffset: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfoExtended!

  """A list of edges."""
  edges: [PredictionEdge]!
}

"""An edge in a connection."""
type PredictionEdge {
  """The item at the end of the edge"""
  node: Prediction

  """A cursor for use in pagination"""
  cursor: String!
}

"""The root of all... queries"""
type Query {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Fetches objects given their IDs"""
  nodes(
    """The IDs of objects"""
    ids: [ID!]!
  ): [Node]!
  me: User
  user(id: ID!): User
  users(after: String, first: Int, before: String, last: Int): UserConnection
  userByEth(address: String!): User
  challenge(id: ID!): Challenge
  challenges(after: String, first: Int, before: String, last: Int, search: String): ChallengeConnection
  prediction(id: ID!): Prediction
  predictions(after: String, first: Int, before: String, last: Int, search: String): PredictionConnection
  donation(id: ID!): Donation
  donations(after: String, first: Int, before: String, last: Int): DonationConnection
  comment(id: ID!): Comment
  comments(after: String, first: Int, before: String, last: Int, search: String): CommentConnection
  challengeCard(id: ID!): ChallengeCard
  challengeCards(after: String, first: Int, before: String, last: Int, search: String): ChallengeCardConnection
}

type Subscription {
  CommentAdded(input: CommentAddedInput!): CommentAddedPayload
}

input ToggleActiveInput {
  challengeId: String!
  clientMutationId: String
}

type ToggleActivePayload {
  active: Boolean!
  error: String
  clientMutationId: String
}

"""User data"""
type User implements Node {
  """The ID of an object"""
  id: ID!
  _id: ID!
  username: String
  addresses: [String]!
  burner: Boolean!
  predictions(after: String, first: Int, before: String, last: Int): PredictionConnection!
  donations(after: String, first: Int, before: String, last: Int): DonationConnection!
  createdChallenges(after: String, first: Int, before: String, last: Int): ChallengeConnection!
}

"""A connection to a list of items."""
type UserConnection {
  """Number of items in this connection"""
  count: Int!

  """
  A count of the total number of objects in this connection, ignoring pagination.
      This allows a client to fetch the first five objects by passing "5" as the
      argument to "first", then fetch the total count so it could display "5 of 83",
      for example.
  """
  totalCount: Int!

  """Offset from start"""
  startCursorOffset: Int!

  """Offset till end"""
  endCursorOffset: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfoExtended!

  """A list of edges."""
  edges: [UserEdge]!
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge"""
  node: User

  """A cursor for use in pagination"""
  cursor: String!
}
